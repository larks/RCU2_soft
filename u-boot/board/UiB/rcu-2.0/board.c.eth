/*
 * board/UiB/rcu-2.0/board.c
 *
 * Board specific code for the SmartFusion2 SoC on the ALICE Time Projection Chamber RCU2 
 *
 ** This file is property of and copyright by the Experimental Nuclear 
 ** Physics Group, Dep. of Physics and Technology
 ** University of Bergen, Norway, 2014
 ** This file has been written by Lars Bratrud,
 ** Lars.Bratrud@cern.ch
 **
 ** Permission to use, copy, modify and distribute this software and its  
 ** documentation strictly for non-commercial purposes is hereby granted  
 ** without fee, provided that the above copyright notice appears in all  
 ** copies and that both the copyright notice and this permission notice  
 ** appear in the supporting documentation. The authors make no claims    
 ** about the suitability of this software for any purpose. It is         
 ** provided "as is" without express or implied warranty.   
 */

#include <common.h>
#include <netdev.h>
#include <asm/arch/ddr.h>
#include <asm/arch/comblk.h>

//#include <asm/arch-m2s/m2s.h>

//const uint8_t frame_size = 16u;

/*
** DDL2 SERDES specific from SoftConsole
*/
typedef struct
{
    uint32_t * p_reg;
    uint32_t value;
} cfg_addr_value_pair_t;

const cfg_addr_value_pair_t g_m2s_serdes_0_config[] =
{
    { (uint32_t*)( 0x40028000 + 0x2028 ), 0x10F } /* SYSTEM_CONFIG_PHY_MODE_1 */ ,
    { (uint32_t*)( 0x40028000 + 0x1198 ), 0x30 } /* LANE0_PHY_RESET_OVERRIDE */ ,
    { (uint32_t*)( 0x40028000 + 0x1000 ), 0x80 } /* LANE0_CR0 */ ,
    { (uint32_t*)( 0x40028000 + 0x1004 ), 0x20 } /* LANE0_ERRCNT_DEC */ ,
    { (uint32_t*)( 0x40028000 + 0x1008 ), 0xF8 } /* LANE0_RXIDLE_MAX_ERRCNT_THR */ ,
    { (uint32_t*)( 0x40028000 + 0x100c ), 0x80 } /* LANE0_IMPED_RATIO */ ,
    { (uint32_t*)( 0x40028000 + 0x1014 ), 0x13 } /* LANE0_PLL_M_N */ ,
    { (uint32_t*)( 0x40028000 + 0x1018 ), 0x1B } /* LANE0_CNT250NS_MAX */ ,
    { (uint32_t*)( 0x40028000 + 0x1024 ), 0x80 } /* LANE0_TX_AMP_RATIO */ ,
    { (uint32_t*)( 0x40028000 + 0x1030 ), 0x10 } /* LANE0_ENDCALIB_MAX */ ,
    { (uint32_t*)( 0x40028000 + 0x1034 ), 0x38 } /* LANE0_CALIB_STABILITY_COUNT */ ,
    { (uint32_t*)( 0x40028000 + 0x103c ), 0x70 } /* LANE0_RX_OFFSET_COUNT */ ,
    { (uint32_t*)( 0x40028000 + 0x11d4 ), 0x2 } /* LANE0_GEN1_TX_PLL_CCP */ ,
    { (uint32_t*)( 0x40028000 + 0x11d8 ), 0x2 } /* LANE0_GEN1_RX_PLL_CCP */ ,
    { (uint32_t*)( 0x40028000 + 0x1198 ), 0x0 } /* LANE0_PHY_RESET_OVERRIDE */ ,
    { (uint32_t*)( 0x40028000 + 0x1200 ), 0x1 } /* LANE0_UPDATE_SETTINGS */ ,
    { (uint32_t*)( 0x40028000 + 0x2028 ), 0xF0F } /* SYSTEM_CONFIG_PHY_MODE_1 */ 
};

#define SDIF_RELEASED_MASK  0x00000002u
#define CONFIG_1_DONE   1u
#define CONFIG_2_DONE   2u
#define SYSREG_FPGA_SOFTRESET_MASK          ( (uint32_t)0x01u << 16u )
#define INIT_DONE_MASK 0x00000001u
#define SERDES_0_CFG_NB_OF_PAIRS 17u /* From sys_config_SERDESIF_0*/


/*
 * SERDES1 registers for the Marvell M881111 Ethernet PHY
*/

#define SERDES1_CFG_BASE			0x4002C000
const cfg_addr_value_pair_t g_m2s_serdes_1_config[] =
{
    { (uint32_t*)( 0x4002C000 + 0x2028 ), 0x80F } /* SYSTEM_CONFIG_PHY_MODE_1 */ ,
    { (uint32_t*)( 0x4002C000 + 0x1d98 ), 0x30 } /* LANE3_PHY_RESET_OVERRIDE */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c00 ), 0x80 } /* LANE3_CR0 */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c04 ), 0x20 } /* LANE3_ERRCNT_DEC */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c08 ), 0xF8 } /* LANE3_RXIDLE_MAX_ERRCNT_THR */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c0c ), 0x80 } /* LANE3_IMPED_RATIO */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c14 ), 0x29 } /* LANE3_PLL_M_N */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c18 ), 0x20 } /* LANE3_CNT250NS_MAX */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c24 ), 0x80 } /* LANE3_TX_AMP_RATIO */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c30 ), 0x10 } /* LANE3_ENDCALIB_MAX */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c34 ), 0x38 } /* LANE3_CALIB_STABILITY_COUNT */ ,
    { (uint32_t*)( 0x4002C000 + 0x1c3c ), 0x70 } /* LANE3_RX_OFFSET_COUNT */ ,
    { (uint32_t*)( 0x4002C000 + 0x1dd4 ), 0x2 } /* LANE3_GEN1_TX_PLL_CCP */ ,
    { (uint32_t*)( 0x4002C000 + 0x1dd8 ), 0x22 } /* LANE3_GEN1_RX_PLL_CCP */ ,
    { (uint32_t*)( 0x4002C000 + 0x1d98 ), 0x0 } /* LANE3_PHY_RESET_OVERRIDE */ ,
    { (uint32_t*)( 0x4002C000 + 0x1e00 ), 0x1 } /* LANE3_UPDATE_SETTINGS */ ,
    { (uint32_t*)( 0x4002C000 + 0x2028 ), 0xF0F } /* SYSTEM_CONFIG_PHY_MODE_1 */ 
};
#define SERDES_1_CFG_NB_OF_PAIRS 17u

/* 
 * SERDES0 registers for the DDL2
 * extracted from SoftConsole files generated by Libero 
 */

#define SERDES0_LANE0_REGS			0x40028000
#define SYSTEM_CONFIG_PHY_MODE_1 	0x2028
#define LANE0_PHY_RESET_OVERRIDE	0x1198
#define LANE0_CR0					0x1000
#define LANE0_ERRCNT_DEC			0x1004
#define LANE0_RXIDLE_MAX_ERRCNT_THR	0x1008
#define LANE0_IMPED_RATIO			0x100c
#define LANE0_PLL_M_N				0x1014
#define LANE0_CNT250NS_MAX			0x1018
#define LANE0_TX_AMP_RATIO			0x1024
#define LANE0_ENDCALIB_MAX			0x1030
#define LANE0_CALIB_STABILITY_COUNT 0x1034
#define LANE0_RX_OFFSET_COUNT		0x103c
#define LANE0_GEN1_TX_PLL_CCP		0x11d4
#define LANE0_GEN1_RX_PLL_CCP		0x11d8
#define LANE0_UPDATE_SETTINGS		0x1200

/*
 * Generate DDR timings depending on the following DDR clock
 */
#define M2S_DDR_MHZ		2*(CONFIG_SYS_M2S_SYSREF / (1000 * 1000))

/*
 * Common conversion macros used for DDR cfg
 */

#define M2S_CLK_VAL(ns, div)	((((ns) * M2S_DDR_MHZ) / div))
#define M2S_CLK_MOD(ns, div)	((((ns) * M2S_DDR_MHZ) % div))

#define M2S_CLK_MIN(ns)		(M2S_CLK_MOD(ns,1000) ?			\
				 M2S_CLK_VAL(ns,1000) + 1 :		\
				 M2S_CLK_VAL(ns,1000))
#define M2S_CLK32_MIN(ns)	(M2S_CLK_MOD(ns,32000) ?		\
				 M2S_CLK_VAL(ns,32000) + 1 :		\
				 M2S_CLK_VAL(ns,32000))
#define M2S_CLK1024_MIN(ns)	(M2S_CLK_MOD(ns,1024000) ?		\
				 M2S_CLK_VAL(ns,1024000) + 1 :		\
				 M2S_CLK_VAL(ns,1024000))
#define M2S_CLK_MAX(ns)		(M2S_CLK_VAL(ns,1000))
#define M2S_CLK32_MAX(ns)	(M2S_CLK_VAL(ns,32000))
#define M2S_CLK1024_MAX(ns)	(M2S_CLK_VAL(ns,1024000))



/// ethernet routines ////


typedef enum
  {
    MAC10MBPS     = 0x00,
    MAC100MBPS    = 0x01,
    MAC1000MBPS   = 0x02,
    INVALID_SPEED = 0x03
  } MAC_speed_t;

typedef enum{
  RMII            = 0x00, 
  RGMII           = 0x01,
  TBI             = 0x02,
  MII             = 0x03,
  GMII            = 0x04,
  INVALID_INF
} MAC_interface_t;

struct MAC_cfg_t{
  uint32_t speed_duplex_select;       /* Link speed and duplex mode allowed to setup a link. */
  uint8_t mac_addr[6];                /* Station's MAC address */
  uint8_t phy_addr;                   /* Address of Ethernet PHY on MII management interface. */
  MAC_interface_t interface;          /* PHY interface type: RMII/ RGMII/ MII /GMII / TBI for SGMII */
  uint8_t tx_edc_enable;              /* Enable / disable error detection and correction for tx FIFOs */
  uint8_t rx_edc_enable;              /* Enable / disable error detection and correction for rx FIFOs */
  uint8_t preamble_length;            /* 4-bit Length of preamble field: default value is 0x7 */
  uint8_t hugeframe_enable;           /* Enable / disable huge frame support: default is disable 0 */
  uint8_t length_field_check;         /* Enable / disable length field checking */
  uint8_t pad_n_CRC;                  /* Enable / disable padding and appending CRC */
  uint8_t append_CRC;                 /* Enable / disable appending CRC */
  uint8_t fullduplex;                 /* Enable / disable full duplex: default is disable 0 */
  uint8_t loopback;                   /* Enable / disable loopback mode: default is disable 0 */
  uint8_t rx_flow_ctrl;               /* Enable / disable receiver flow control: default is disable 0 */
  uint8_t tx_flow_ctrl;               /* Enable / disable transmitter flow control: default is disable 0 */
  uint8_t min_IFG;                    /* 8-bit minimum inter-frame gap value */
  uint8_t btb_IFG;                    /* 7-bit back to back inter-frame gap value */
  uint8_t max_retx_tries;             /* 5-bit maximum retransmission tries value: default is 0xF */
  uint8_t excessive_defer;            /* Enable / disable transmission of packet that exceeded max collisions: default is disable 0 */
  uint8_t nobackoff;                  /* Enable / disable back off. default is disable 0 */
  uint8_t backpres_nobackoff;         /* Enable / disable back off in back pressure mode: default is disable 0 */
  uint8_t ABEB_enable;                /* Enable / disable arbitrary binary exponential back-off: default is disable 0 */
  uint8_t ABEB_truncvalue;            /* 4-bit alternative binary exponential back-off value: default is 0xA */
  uint8_t phyclk;                     /* 3-bit MGMT clock divider value */
  uint8_t supress_preamble;           /* Enable / disable preamble suppression at PHY: default is disable 0 */
  uint8_t autoscan_phys;              /* Enable / disable auto scanning of PHYs with programmed addresses: default is disable 0 */
  uint16_t max_frame_length;          /* Maximum frame length: default value is 0x0600(1536d) */
  uint16_t non_btb_IFG;               /* 14-bit non back to back inter-frame gap value */
  uint16_t slottime;                  /* 10-bit collision window value : default is 0x37 */
  uint32_t framedrop_mask;            /* 18-bit mask to drop frames based on receive statistics */
};

typedef struct MAC_tx_desc MAC_tx_desc_t;
typedef struct MAC_rx_desc MAC_rx_desc_t;

struct MAC_tx_desc
{
  uint8_t const * pkt_start_addr; /* Packet start address */
  volatile uint32_t pkt_size;     /* Packet size & Per packet override flags */
  MAC_tx_desc_t * next_desriptor; /* Link to next descriptor */
  int32_t index;                  /* Index: helps in handling interrupts */
  void * caller_info;             /* Pointer to user specific data */
};

struct MAC_rx_desc
{
  uint8_t * pkt_start_addr;       /* Packet start address */
  volatile uint32_t pkt_size;     /* Packet size & Per packet override flags */
  MAC_rx_desc_t * next_desriptor; /* Link to next descriptor */
  int32_t index;                  /* Index: helps in handling interrupts */
  void * caller_info;             /* Pointer to user specific data */
};

/*******************************************************************************
 * SmartFusion2 Ethernet MAC instance
 * A local record of this type "g_mac" will be created and maintained by the
 * driver.
 */

#define MSS_MAC_RX_RING_SIZE 2
#define MSS_MAC_TX_RING_SIZE 2
#define PHY 3



struct MAC_instance_t
{
  MAC_tx_desc_t               tx_desc_tab[MSS_MAC_TX_RING_SIZE]; /* Transmit descriptor table */
  MAC_rx_desc_t               rx_desc_tab[MSS_MAC_RX_RING_SIZE]; /* Receive descriptor table */
  //MAC_transmit_callback_t     tx_complete_handler;
  //MAC_receive_callback_t      pckt_rx_callback;
  int16_t                     nb_available_tx_desc;
  int16_t                     first_tx_index;
  int16_t                     last_tx_index;
  int16_t                     next_tx_index;
  int16_t                     nb_available_rx_desc;
  int16_t                     next_free_rx_desc_index;
  int16_t                     first_rx_desc_index;
};


void cmd_sgmmi_rx_loop(int speed);
void cmd_sgmmi_init(int speed);
static void m2s_eth_recv(void *pkt);
void MSS_MAC_init(MAC_cfg_t *cfg);
static void set_bit_reg32(volatile uint32_t * reg, uint8_t bit);
static void clear_bit_reg32(volatile uint32_t * reg, uint8_t bit);
static void config_mac_hw(const MAC_cfg_t * cfg);
static void assign_station_addr(const uint8_t mac_addr[6]);
static void tx_desc_ring_init(void);
static void rx_desc_ring_init(void);
void phy_init(MAC_cfg_t * cfg);
uint16_t MSS_MAC_read_phy_reg(uint8_t phyaddr, uint8_t regaddr);
void MSS_MAC_write_phy_reg(uint8_t phyaddr, uint8_t regaddr, uint16_t regval);
void phy_set_link_speed(uint32_t speed_duplex_select);
void phy_autonegotiate(void);
static void update_mac_cfg(void);
uint8_t phy_get_link_status(MAC_speed_t * speed, uint8_t *     fullduplex);

int g_rcu2_phy_mdix_disable = 1;
int g_rcu2_phy_disable = 0;
MAC_cfg_t g_mac_config;
static MAC_instance_t g_mac;


uint8_t g_rcu2_mac_addr[6] = { 0x00, 0x18, 0xF3, 0xF4, 0x79, 0xDC };
uint8_t g_rcu2_ip_addr[4] = { 10, 1, 5, 222 };





struct m2s_eth_dma_bd {
  volatile u8 *frame;                    /* Pointer to frame buffer    */
  u32 cfg_size;                  /* Cfg flags and frame size   */
  struct m2s_eth_dma_bd *next;   /* Pointer to next BD in chain*/
};

static volatile struct m2s_eth_dma_bd m2s_bd_tx[1];
static volatile struct m2s_eth_dma_bd m2s_bd_rx[1];

#define M2S_BD_EMPTY            (1 << 31)       /* Empty flag                 */
#define M2S_BD_SIZE_MSK         0xFFF           /* Frame size mask            */

#define M2S_MAC_DMA_CTRL_ENA    (1 << 0)        /* Enable Tx/Rx DMA xfers     */

#define MSS_MAC_MAX_PACKET_SIZE             1536u
#define MSS_MAC_MAX_TX_BUF_SIZE             MSS_MAC_MAX_PACKET_SIZE
#define MSS_MAC_MAX_RX_BUF_SIZE             MSS_MAC_MAX_PACKET_SIZE


static uint8_t mac_rx_buffer_1[MSS_MAC_MAX_RX_BUF_SIZE];

/*------------------------------------------------------------------------------
 * DMA descriptor definitions
 */
#define DMA_DESC_EMPTY_FLAG_MASK        ((uint32_t)1u << 31u)
#define DMA_DESC_PKT_SIZE_MASK          0xFFFu

/*------------------------------------------------------------------------------
 * DMA descriptor packet size 
 */
#define DMA_PKTCOUNT                    16u
#define DMA_PKTCOUNT_MASK               ((uint32_t)0xFFu << 16)







/*
 * MT41J256M8 params & timings
 */
//#define DDR_BL			8	/* Burst length (value)		*/
//#define DDR_MR_BL		3	/* Burst length (power of 2)	*/
//#define DDR_BT			0	/* Burst type int(1)/seq(0)	*/

//#define DDR_CL			9	/* CAS (read) latency		*/
//#define DDR_WL			1	/* Write latency		*/
/*#define DDR_tMRD		2*/
/*#define DDR_tWTR		2*/
/*#define DDR_tXP			1*/
/*#define DDR_tCKE		1*/

/*#define DDR_tRFC		M2S_CLK_MIN(72)*/
/*#define DDR_tREFI		M2S_CLK32_MAX(7800)*/
/*#define DDR_tCKE_pre		M2S_CLK1024_MIN(200000)*/
/*#define DDR_tCKE_post		M2S_CLK1024_MIN(400)*/
/*#define DDR_tRCD		M2S_CLK_MIN(18)*/
/*#define DDR_tRRD		M2S_CLK_MIN(12)*/
/*#define DDR_tRP			M2S_CLK_MIN(18)*/
/*#define DDR_tRC			M2S_CLK_MIN(60)*/
/*#define DDR_tRAS_max		M2S_CLK1024_MAX(70000)*/
/*#define DDR_tRAS_min		M2S_CLK_MIN(42)*/
/*#define DDR_tWR			M2S_CLK_MIN(15)*/

/*
 * There are no these timings exactly in spec, so take smth
 */
#define DDR_tCCD		2	/* 2-reads/writes (bank A to B)	*/

DECLARE_GLOBAL_DATA_PTR;

int board_init(void)
{
#if 0
	/* Values extracted from SoftConsole files generated by Libero */
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + SYSTEM_CONFIG_PHY_MODE_1) = 0x10F;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_PHY_RESET_OVERRIDE) = 0x30;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_CR0) = 0x80;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_ERRCNT_DEC) = 0x20;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_RXIDLE_MAX_ERRCNT_THR) = 0xF8;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_IMPED_RATIO) = 0x80;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_PLL_M_N) = 0x13;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_CNT250NS_MAX) = 0x1B;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_TX_AMP_RATIO) = 0x80;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_ENDCALIB_MAX) = 0x10;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_CALIB_STABILITY_COUNT) = 0x38;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_RX_OFFSET_COUNT) = 0x70;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_GEN1_TX_PLL_CCP) = 0x2;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_GEN1_RX_PLL_CCP) = 0x2;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_PHY_RESET_OVERRIDE) = 0x0;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_UPDATE_SETTINGS) = 0x1;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + SYSTEM_CONFIG_PHY_MODE_1) = 0xF0F;
	/* Signal to CoreSF2Reset that peripheral configuration registers have been written.*/
	CORE_SF2_CFG->config_done = 1u;
#endif
	/* 
	** DDL2 SERDES stuff from SystemInit() in SoftConsole generated code
	*/	
	uint32_t sdif_released; /* if MSS_SYS_SERDES_CONFIG_BY_CORTEX */
	uint32_t init_done; /* if MSS_SYS_CORESF2RESET_USED */
	//uint32_t core_cfg_version; /* if MSS_SYS_SERDES_CONFIG_BY_CORTEX */
	/*core_cfg_version = CORE_SF2_CFG->IP_VERSION_SR;*/
	
	/*configure_serdes_intf()*/
	uint32_t inc = 0;
	for(inc = 0; inc < SERDES_0_CFG_NB_OF_PAIRS; ++inc){
	  *g_m2s_serdes_0_config[inc].p_reg = g_m2s_serdes_0_config[inc].value;
	}
	
	//	if(core_cfg_version >= CORE_CONFIGP_V7_0)
	//    {
        CORE_SF2_CFG->config_done = CONFIG_1_DONE;
	
        /* Poll for SDIF_RELEASED. */
        do
        {
            sdif_released = ((CORE_SF2_CFG->init_done) & SDIF_RELEASED_MASK);
        } while (0u == sdif_released);
	//    }
	/* CoreSF2Reset stuff */
	M2S_SYSREG->soft_reset_cr &= ~SYSREG_FPGA_SOFTRESET_MASK;
	CORE_SF2_CFG->config_done |= (CONFIG_1_DONE | CONFIG_2_DONE);
/* Wait for INIT_DONE from CoreSF2Reset. */
#if 0
	do
	  {
	    init_done = CORE_SF2_CFG->init_done & INIT_DONE_MASK;
	  } while (0u == init_done);
#endif
	return 0;
}

int checkboard(void)
{
  printf("Board: RCU-2.0 Rev %s\n",
	 CONFIG_SYS_BOARD_REV_STR);
  
  int inc=0;

  for(inc = 0; inc < SERDES_0_CFG_NB_OF_PAIRS; ++inc){
    printf("%p -- 0x%x\n", g_m2s_serdes_0_config[inc].p_reg, *g_m2s_serdes_0_config[inc].p_reg);
  }


  for(inc = 0; inc < SERDES_1_CFG_NB_OF_PAIRS; ++inc){
    printf("%p -- 0x%x\n", g_m2s_serdes_1_config[inc].p_reg, *g_m2s_serdes_1_config[inc].p_reg);
  }

  
  return 0;
}

/*
 * Initialize DRAM
 */
int dram_init (void)
{
#if ( CONFIG_NR_DRAM_BANKS > 0 )
	volatile struct ddr_regs	*ddr = (void *)0x40020000;
	u16				val;

	/*
	 * Enable access to MDDR regs
	 */
	M2S_SYSREG->mddr_cr = (1 << 0);

	/*
	 * No non-bufferable regions
	 */
	M2S_SYSREG->ddrb_nb_size_cr = 0;

	ddr->ddrc.DYN_POWERDOWN_CR = (0 << REG_DDRC_POWERDOWN_EN);

	/*
	 * Apply DDR settings from Microsemi
	 */
	ddr->ddrc.DYN_SOFT_RESET_CR =			0;
	ddr->ddrc.DYN_REFRESH_1_CR =			0x27de;
	ddr->ddrc.DYN_REFRESH_2_CR =			0x30f;
	/* ddr->ddrc.DYN_POWERDOWN_CR =			0x02; */
	ddr->ddrc.DYN_DEBUG_CR =			0x00;
	ddr->ddrc.MODE_CR =				0x101;
	ddr->ddrc.ADDR_MAP_BANK_CR =			0x999;
	ddr->ddrc.ECC_DATA_MASK_CR =			0x0000;
	ddr->ddrc.ADDR_MAP_COL_1_CR =			0x3333;
	ddr->ddrc.ADDR_MAP_COL_2_CR =			0xffff;
	ddr->ddrc.ADDR_MAP_ROW_1_CR =			0x8888;
	ddr->ddrc.ADDR_MAP_ROW_2_CR =			0x8ff;
	ddr->ddrc.INIT_1_CR =				0x0001;
	ddr->ddrc.CKE_RSTN_CYCLES_1_CR =		0x4242;
	ddr->ddrc.CKE_RSTN_CYCLES_2_CR =		0x8;
	ddr->ddrc.INIT_MR_CR =				0x520;
	ddr->ddrc.INIT_EMR_CR =				0x44;
	ddr->ddrc.INIT_EMR2_CR =			0x0000;
	ddr->ddrc.INIT_EMR3_CR =			0x0000;
	ddr->ddrc.DRAM_BANK_TIMING_PARAM_CR =		0xce0;
	ddr->ddrc.DRAM_RD_WR_LATENCY_CR =		0x86;
	ddr->ddrc.DRAM_RD_WR_PRE_CR =			0x235;
	ddr->ddrc.DRAM_MR_TIMING_PARAM_CR =		0x5c;
	ddr->ddrc.DRAM_RAS_TIMING_CR =			0x10f;
	ddr->ddrc.DRAM_RD_WR_TRNARND_TIME_CR =		0x178;
	ddr->ddrc.DRAM_T_PD_CR =			0x33;
	ddr->ddrc.DRAM_BANK_ACT_TIMING_CR =		0x1947;
	ddr->ddrc.ODT_PARAM_1_CR =			0x10;
	ddr->ddrc.ODT_PARAM_2_CR =			0x0000;
	ddr->ddrc.ADDR_MAP_COL_3_CR =			0x3300;
	/* ddr->ddrc.DEBUG_CR =				0x3300; */
	ddr->ddrc.MODE_REG_RD_WR_CR =			0x0000;
	ddr->ddrc.MODE_REG_DATA_CR =			0x0000;
	ddr->ddrc.PWR_SAVE_1_CR =			0x506;
	ddr->ddrc.PWR_SAVE_2_CR =			0x0000;
	ddr->ddrc.ZQ_LONG_TIME_CR =			0x200;
	ddr->ddrc.ZQ_SHORT_TIME_CR =			0x40;
	ddr->ddrc.ZQ_SHORT_INT_REFRESH_MARGIN_1_CR =	0x12;
	ddr->ddrc.ZQ_SHORT_INT_REFRESH_MARGIN_2_CR =	0x2;
	ddr->ddrc.PERF_PARAM_1_CR =			0x4000;
	ddr->ddrc.HPR_QUEUE_PARAM_1_CR =		0x80f8;
	ddr->ddrc.HPR_QUEUE_PARAM_2_CR =		0x7;
	ddr->ddrc.LPR_QUEUE_PARAM_1_CR =		0x80f8;
	ddr->ddrc.LPR_QUEUE_PARAM_2_CR =		0x7;
	ddr->ddrc.WR_QUEUE_PARAM_CR =			0x200;
	ddr->ddrc.PERF_PARAM_2_CR =			0x400;
	ddr->ddrc.PERF_PARAM_3_CR =			0x0000;
	ddr->ddrc.DFI_RDDATA_EN_CR =			0x5;
	ddr->ddrc.DFI_MIN_CTRLUPD_TIMING_CR =		0x0003;
	ddr->ddrc.DFI_MAX_CTRLUPD_TIMING_CR =		0x0040;
	ddr->ddrc.DFI_WR_LVL_CONTROL_1_CR =		0x0000;
	ddr->ddrc.DFI_WR_LVL_CONTROL_2_CR =		0x0000;
	ddr->ddrc.DFI_RD_LVL_CONTROL_1_CR =		0x0000;
	ddr->ddrc.DFI_RD_LVL_CONTROL_2_CR =		0x0000;
	ddr->ddrc.DFI_CTRLUPD_TIME_INTERVAL_CR =	0x309;
	/* ddr->ddrc.DYN_SOFT_RESET_CR2 =		0x4; */
	ddr->ddrc.AXI_FABRIC_PRI_ID_CR =		0x0000;
	ddr->ddrc.ECC_INT_CLR_REG =			0x0000;

	ddr->phy.DYN_BIST_TEST_CR =			0x0;
	ddr->phy.DYN_BIST_TEST_ERRCLR_1_CR =		0x0;
	ddr->phy.DYN_BIST_TEST_ERRCLR_2_CR =		0x0;
	ddr->phy.DYN_BIST_TEST_ERRCLR_3_CR =		0x0;
	ddr->phy.BIST_TEST_SHIFT_PATTERN_1_CR =		0x0;
	ddr->phy.BIST_TEST_SHIFT_PATTERN_2_CR =		0x0;
	ddr->phy.BIST_TEST_SHIFT_PATTERN_3_CR =		0x0;
	ddr->phy.DYN_LOOPBACK_TEST_CR =			0x0000;
	ddr->phy.BOARD_LOOPBACK_CR =			0x0;
	ddr->phy.CTRL_SLAVE_RATIO_CR =			0x80;
	ddr->phy.CTRL_SLAVE_FORCE_CR =			0x0;
	ddr->phy.CTRL_SLAVE_DELAY_CR =			0x0;
	ddr->phy.DATA_SLICE_IN_USE_CR =			0xf;
	ddr->phy.LVL_NUM_OF_DQ0_CR =			0x0;
	ddr->phy.DQ_OFFSET_1_CR =			0x0;
	ddr->phy.DQ_OFFSET_2_CR =			0x0;
	ddr->phy.DQ_OFFSET_3_CR =			0x0;
	ddr->phy.DIS_CALIB_RST_CR =			0x0;
	ddr->phy.DLL_LOCK_DIFF_CR =			0xb;
	ddr->phy.FIFO_WE_IN_DELAY_1_CR =		0x0;
	ddr->phy.FIFO_WE_IN_DELAY_2_CR =		0x0;
	ddr->phy.FIFO_WE_IN_DELAY_3_CR =		0x0;
	ddr->phy.FIFO_WE_IN_FORCE_CR =			0x0;
	ddr->phy.FIFO_WE_SLAVE_RATIO_1_CR =		0x80;
	ddr->phy.FIFO_WE_SLAVE_RATIO_2_CR =		0x2004;
	ddr->phy.FIFO_WE_SLAVE_RATIO_3_CR =		0x100;
	ddr->phy.FIFO_WE_SLAVE_RATIO_4_CR =		0x8;
	ddr->phy.GATELVL_INIT_MODE_CR =			0x0;
	ddr->phy.GATELVL_INIT_RATIO_1_CR =		0x0;
	ddr->phy.GATELVL_INIT_RATIO_2_CR =		0x0;
	ddr->phy.GATELVL_INIT_RATIO_3_CR =		0x0;
	ddr->phy.GATELVL_INIT_RATIO_4_CR =		0x0;
	ddr->phy.LOCAL_ODT_CR =				0x1;
	ddr->phy.INVERT_CLKOUT_CR =			0x0;
	ddr->phy.RD_DQS_SLAVE_DELAY_1_CR =		0x0;
	ddr->phy.RD_DQS_SLAVE_DELAY_2_CR =		0x0;
	ddr->phy.RD_DQS_SLAVE_DELAY_3_CR =		0x0;
	ddr->phy.RD_DQS_SLAVE_FORCE_CR =		0x0;
	ddr->phy.RD_DQS_SLAVE_RATIO_1_CR =		0x4050;
	ddr->phy.RD_DQS_SLAVE_RATIO_2_CR =		0x501;
	ddr->phy.RD_DQS_SLAVE_RATIO_3_CR =		0x5014;
	ddr->phy.RD_DQS_SLAVE_RATIO_4_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_DELAY_1_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_DELAY_2_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_DELAY_3_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_FORCE_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_RATIO_1_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_RATIO_2_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_RATIO_3_CR =		0x0;
	ddr->phy.WR_DQS_SLAVE_RATIO_4_CR =		0x0;
	ddr->phy.WR_DATA_SLAVE_DELAY_1_CR =		0x0;
	ddr->phy.WR_DATA_SLAVE_DELAY_2_CR =		0x0;
	ddr->phy.WR_DATA_SLAVE_DELAY_3_CR =		0x0;
	ddr->phy.WR_DATA_SLAVE_FORCE_CR =		0x0;
	ddr->phy.WR_DATA_SLAVE_RATIO_1_CR =		0x50;
	ddr->phy.WR_DATA_SLAVE_RATIO_2_CR =		0x501;
	ddr->phy.WR_DATA_SLAVE_RATIO_3_CR =		0x5010;
	ddr->phy.WR_DATA_SLAVE_RATIO_4_CR =		0x0;
	ddr->phy.WRLVL_INIT_MODE_CR =			0x0;
	ddr->phy.WRLVL_INIT_RATIO_1_CR =		0x0;
	ddr->phy.WRLVL_INIT_RATIO_2_CR =		0x0;
	ddr->phy.WRLVL_INIT_RATIO_3_CR =		0x0;
	ddr->phy.WRLVL_INIT_RATIO_4_CR =		0x0;
	ddr->phy.WR_RD_RL_CR =				0x43;
	ddr->phy.RDC_FIFO_RST_ERRCNTCLR_CR =		0x0;
	ddr->phy.RDC_WE_TO_RE_DELAY_CR =		0x3;
	ddr->phy.USE_FIXED_RE_CR =			0x1;
	ddr->phy.USE_RANK0_DELAYS_CR =			0x1;
	ddr->phy.USE_LVL_TRNG_LEVEL_CR =		0x0;
	ddr->phy.DYN_CONFIG_CR =			0x0000;
	ddr->phy.RD_WR_GATE_LVL_CR =			0x0;

	/* ddr->fic.NB_ADDR_CR =			0x0; */
	/* ddr->fic.NBRWB_SIZE_CR =			0x0; */
	/* ddr->fic.WB_TIMEOUT_CR =			0x0; */
	/* ddr->fic.HPD_SW_RW_EN_CR =			0x0; */
	/* ddr->fic.HPD_SW_RW_INVAL_CR =		0x0; */
	/* ddr->fic.SW_WR_ERCLR_CR =			0x0; */
	/* ddr->fic.ERR_INT_ENABLE_CR =			0x0; */
	/* ddr->fic.NUM_AHB_MASTERS_CR =		0x0; */
	/* ddr->fic.LOCK_TIMEOUTVAL_1_CR =		0x0; */
	/* ddr->fic.LOCK_TIMEOUTVAL_2_CR =		0x0; */
	/* ddr->fic.LOCK_TIMEOUT_EN_CR =		0x0; */

	ddr->phy.DYN_RESET_CR =				0x1;
	ddr->ddrc.DYN_SOFT_RESET_CR =			0x0001;

	/*
	 * Set up U-Boot global data
	 */
	gd->bd->bi_dram[0].start = CONFIG_SYS_RAM_BASE;
	gd->bd->bi_dram[0].size = CONFIG_SYS_RAM_SIZE;

	//ddl2_serdes_init();
#endif
	return 0;
}

int misc_init_r(void)
{
	/* Try to force SPI */
/*	MSS_SPI_init(&g_mss_spi0);
	MSS_SPI_configure_master_mode(&g_mss_spi0,
                                  MSS_SPI_SLAVE_0,
                                  MSS_SPI_MODE0,
                                  MSS_SPI_PCLK_DIV_256,
                                  frame_size);

    This did nothing
  */        
	return 0;
}

#ifdef CONFIG_M2S_ETH
int board_eth_init(bd_t *bis)
{
//	*(unsigned int *)(SERDES1_CFG_BASE + SYSTEM_CONFIG_PHY_MODE_1) = 0x80F;/*Lane 3*/
//	CORE_SF2_CFG->config_done = 1u;
  //return 0;

  
  cmd_sgmmi_rx_loop(10);

  return m2s_eth_driver_init(bis);
  //return rcu2_eth_driver_init(bis); USE THIS
}
#endif


int ddl2_serdes_init(void)
{

  printf("DDL2_serdes_init\n");
  /* Values extracted from SoftConsole files generated by Libero */
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + SYSTEM_CONFIG_PHY_MODE_1) = 0x10F;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_PHY_RESET_OVERRIDE) = 0x30;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_CR0) = 0x80;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_ERRCNT_DEC) = 0x20;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_RXIDLE_MAX_ERRCNT_THR) = 0xF8;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_IMPED_RATIO) = 0x80;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_PLL_M_N) = 0x13;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_CNT250NS_MAX) = 0x1B;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_TX_AMP_RATIO) = 0x80;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_ENDCALIB_MAX) = 0x10;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_CALIB_STABILITY_COUNT) = 0x38;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_RX_OFFSET_COUNT) = 0x70;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_GEN1_TX_PLL_CCP) = 0x2;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_GEN1_RX_PLL_CCP) = 0x2;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_PHY_RESET_OVERRIDE) = 0x0;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + LANE0_UPDATE_SETTINGS) = 0x1;
	*(volatile uint32_t *)(SERDES0_LANE0_REGS + SYSTEM_CONFIG_PHY_MODE_1) = 0xF0F;
	/* Signal to CoreSF2Reset that peripheral configuration registers have been written.*/
	CORE_SF2_CFG->config_done = 1u;
#if 0 
/* Lars -- look into this... taken from emcraft board file */
/* FIXME: init_done is never signalled after a soft reset if the DDR has been initialized before the reset. */
	while(!CORE_SF2_CFG->init_done)
	{
		;   /* Wait for INIT_DONE from CoreSF2Reset. */
	}
#endif
	
	return 0;
}

void cmd_sgmmi_rx_loop(int speed)
{
  uint8_t linkup;
  uint8_t prev_linkup;
  MAC_speed_t link_speed;
  int rx_len;
  int i=0;

  // init the Ethernet link
  cmd_sgmmi_init(speed);

  printf("cmd_sgmmi_rx(%d)\r\n", speed);
  printf("\r\n");

  // init variables
  prev_linkup = -1;

  // enable receiving

  /*
  m2s_eth_recv(mac_rx_buffer_1);
  
  for (i=0;i<20;i++){
    // check the link status
    linkup = MSS_MAC_get_link_status(&link_speed, NULL);
    if (prev_linkup != linkup){
      uint16_t phy_00_reg_25 = MSS_MAC_read_phy_reg(0x00, 25);
      phy_00_reg_25 &= ~ 0x00C0; // restore LED_LINK100 functionality
      if (linkup){
	//uint16_t phy_00_reg_16 = MSS_MAC_read_phy_reg(0x00, 16);
	uint16_t phy_00_reg_17 = MSS_MAC_read_phy_reg(0x00, 17);
	printf("\r\nLink is up. Speed = %dM, MDIX = %d\r\n\r\n",
	       (link_speed == MAC10MBPS) ? 10 : 100,
	       (unsigned int)((phy_00_reg_17 >> 6) & 1));
	// init dhcp
	//dhcp_send_DHCPDISCOVER();
	printf("  SYSREG->MSSDDR_FACC1_CR = 0x%x \r\n", (unsigned int)SYSREG->MSSDDR_FACC1_CR);
	
	if (link_speed == MAC10MBPS){
	  phy_00_reg_25 |= 0x00C0; // force LED_LINK100 on
	}
      }else{
	printf("\r\nEthernet link is lost.\r\n");
      }
      MSS_MAC_write_phy_reg(0x00, 25, phy_00_reg_25); // update LED_LINK100 functionality
      prev_linkup = linkup;
    } // end of link status check
    
      // handle the incoming traffic
    if ((m2s_bd_rx[0].cfg_size & M2S_BD_EMPTY) == 0){
      MAC->DMA_RX_CTRL = 0; // stop Rx DMA
      rx_len = m2s_bd_rx[0].cfg_size & M2S_BD_SIZE_MSK;
      printf("  DMA_RX_STATUS = 0x%08x, rx_len = %d\r\n", (unsigned int)MAC->DMA_RX_STATUS, rx_len);
      // rearm Rx DMA
      m2s_bd_rx[0].cfg_size = M2S_BD_EMPTY;
      MAC->DMA_RX_DESC = (uint32_t)m2s_bd_rx;
      MAC->DMA_RX_CTRL = M2S_MAC_DMA_CTRL_ENA;
      //m2s_eth_recv(mac_rx_buffer_1);
    } // end of incoming traffic
  } // end of endless loop
  */
}


#define MSS_GPIO_INPUT_MODE              0x0000000002uL
#define MSS_GPIO_OUTPUT_MODE             0x0000000005uL
#define MSS_GPIO_INOUT_MODE              0x0000000003uL

#define MSS_GPIO_IRQ_LEVEL_HIGH           0x0000000000uL
#define MSS_GPIO_IRQ_LEVEL_LOW            0x0000000020uL
#define MSS_GPIO_IRQ_EDGE_POSITIVE        0x0000000040uL
#define MSS_GPIO_IRQ_EDGE_NEGATIVE        0x0000000060uL
#define MSS_GPIO_IRQ_EDGE_BOTH            0x0000000080uL

/////definers of MSS_ETH
#define MSS_MAC_DISABLE                             ( (uint8_t)0 )
#define MSS_MAC_ENABLE                              ( (uint8_t)1 )

/*******************************************************************************
 * API Function return value definitions
 */
#define MSS_MAC_SUCCESS   MSS_MAC_ENABLE
#define MSS_MAC_FAILED    MSS_MAC_DISABLE

/*******************************************************************************
 * Broadcast MAC address 
 */
#define MSS_MAC_BROADCAST_MAC_ADDRESS       0xFF,0xFF,0xFF,0xFF,0xFF,0xFF

/*******************************************************************************
 * Maximum MAC frame size (packet size)
 */


/*******************************************************************************
 * Per Packet Overrides masks in descriptor packet size parameters
 */
#define MSS_MAC_FIFO_TX_CTRL_FRAME          ( (uint32_t)0x00100000 )
#define MSS_MAC_FIFO_TX_NO_CTRL_FRAME       ( ~MSS_MAC_FIFO_TX_CTRL_FRAME )
#define MSS_MAC_FIFO_TX_PERPKT_PAD_FCS      ( (uint32_t)0x00040000 )
#define MSS_MAC_FIFO_TX_PERPKT_NO_PAD_FCS   ( ~MSS_MAC_FIFO_TX_PERPKT_PAD_FCS )
#define MSS_MAC_FIFO_TX_PERPKT_FCS          ( (uint32_t)0x00020000 )
#define MSS_MAC_FIFO_TX_PERPKT_NO_FCS       ( ~MSS_MAC_FIFO_TX_PERPKT_FCS )
#define MSS_MAC_FIFO_TX_PERPKT_ENABLE       ( (uint32_t)0x00010000 )
#define MSS_MAC_FIFO_TX_PERPKT_DISABLE      ( ~MSS_MAC_FIFO_TX_PERPKT_ENABLE )

/*******************************************************************************
 * Transmit and receive packet buffer sizes
 */
/*******************************************************************************
 * Defines for configuration parameters
 */
/* Auto-negotiation enable / disable */
#define MSS_MAC_AUTO_NEGOTIATION_ENABLE             MSS_MAC_ENABLE
#define MSS_MAC_AUTO_NEGOTIATION_DISABLE            MSS_MAC_DISABLE

/* FIFO error detection & correction enable / disable */
#define MSS_MAC_ERR_DET_CORR_ENABLE                 MSS_MAC_ENABLE
#define MSS_MAC_ERR_DET_CORR_DISABLE                MSS_MAC_DISABLE

/* Huge frame support enable / disable */
#define MSS_MAC_HUGE_FRAME_ENABLE                   MSS_MAC_ENABLE
#define MSS_MAC_HUGE_FRAME_DISABLE                  MSS_MAC_DISABLE

/* Length field checking enable / disable */
#define MSS_MAC_LENGTH_FILED_CHECK_ENABLE           MSS_MAC_ENABLE
#define MSS_MAC_LENGTH_FILED_CHECK_DISABLE          MSS_MAC_DISABLE

/* Padding and CRC enable / disable */
#define MSS_MAC_PAD_N_CRC_ENABLE                    MSS_MAC_ENABLE
#define MSS_MAC_PAD_N_CRC_DISABLE                   MSS_MAC_DISABLE

/* Append CRC enable / disable */
#define MSS_MAC_CRC_ENABLE                          MSS_MAC_ENABLE
#define MSS_MAC_CRC_DISABLE                         MSS_MAC_DISABLE

/* Fullduplex mode enable / disable */
#define MSS_MAC_FULLDUPLEX_ENABLE                   MSS_MAC_ENABLE
#define MSS_MAC_FULLDUPLEX_DISABLE                  MSS_MAC_DISABLE

/* Loopback mode enable / disable */
#define MSS_MAC_LOOPBACK_ENABLE                     MSS_MAC_ENABLE
#define MSS_MAC_LOOPBACK_DISABLE                    MSS_MAC_DISABLE

/* Receiver flow control enable / disable */
#define MSS_MAC_RX_FLOW_CTRL_ENABLE                 MSS_MAC_ENABLE
#define MSS_MAC_RX_FLOW_CTRL_DISABLE                MSS_MAC_DISABLE

/* Transmission flow control enable / disable */
#define MSS_MAC_TX_FLOW_CTRL_ENABLE                 MSS_MAC_ENABLE
#define MSS_MAC_TX_FLOW_CTRL_DISABLE                MSS_MAC_DISABLE

/* Excessive defer enable / disable */
#define MSS_MAC_EXSS_DEFER_ENABLE                   MSS_MAC_ENABLE
#define MSS_MAC_EXSS_DEFER_DISABLE                  MSS_MAC_DISABLE

/* No-backoff enable / disable */
#define MSS_MAC_NO_BACKOFF_ENABLE                   MSS_MAC_ENABLE
#define MSS_MAC_NO_BACKOFF_DISABLE                  MSS_MAC_DISABLE

/* Backpressure no-backoff enable / disable */
#define MSS_MAC_BACKPRESS_NO_BACKOFF_ENABLE         MSS_MAC_ENABLE
#define MSS_MAC_BACKPRESS_NO_BACKOFF_DISABLE        MSS_MAC_DISABLE

/* Alternative binary exponential backoff enable / disable */
#define MSS_MAC_ABEB_ENABLE                         MSS_MAC_ENABLE
#define MSS_MAC_ABEB_DISABLE                        MSS_MAC_DISABLE

/* Supress preamble enable / disable */
#define MSS_MAC_SUPPRESS_PREAMBLE_ENABLE            MSS_MAC_ENABLE
#define MSS_MAC_SUPPRESS_PREAMBLE_DISABLE           MSS_MAC_DISABLE

/* Auto-scan PHYs enable / disable */
#define MSS_MAC_PHY_AUTOSCAN_ENABLE                 MSS_MAC_ENABLE
#define MSS_MAC_PHY_AUTOSCAN_DISABLE                MSS_MAC_DISABLE

/* Preamble length default value and maximum value */
#define MSS_MAC_PREAMLEN_DEFVAL                     ( (uint8_t)(0x07) )
#define MSS_MAC_PREAMLEN_MAXVAL                     ( (uint8_t)(0x0F) )

/* Byte / Nibble mode  */
#define MSS_MAC_NIBBLE_MODE                         ( (uint8_t)(0x00) )
#define MSS_MAC_BYTE_MODE                           ( (uint8_t)(0x01) )

/* IPG/IFG values */
#define MSS_MAC_MINIFG_MAXVAL                       ( (uint8_t)(0xFF) )
#define MSS_MAC_MINIFG_DEFVAL                       ( (uint8_t)(0x50) )
#define MSS_MAC_BTBIFG_MAXVAL                       ( (uint8_t)(0x7F) )
#define MSS_MAC_BTBIFG_DEFVAL                       ( (uint8_t)(0x60) )
#define MSS_MAC_NONBTBIFG_DEFVAL                    ( (uint16_t)((0x4000u) | 0x0060u) )
#define MSS_MAC_NONBTBIFG_MAXVAL                    ( (uint16_t)(0x3FFF) )

/* Number of maximum retransmission tries */
#define MSS_MAC_MAXRETX_MAXVAL                      ( (uint8_t)(0x1F) )
#define MSS_MAC_MAXRETX_DEFVAL                      ( (uint8_t)(0x0F) )
#define MSS_MAC_ABEBTRUNC_MAXVAL                    ( (uint8_t)(0x0F) )
#define MSS_MAC_ABEBTRUNC_DEFVAL                    ( (uint8_t)(0x0A) )

/* PHY clock divider values */
#define MSS_MAC_DEF_PHY_CLK                         ( (uint8_t)(0x07) )
#define MSS_MAC_BY4_PHY_CLK                         ( (uint8_t)(0x01) )
#define MSS_MAC_BY6_PHY_CLK                         ( (uint8_t)(0x02) )
#define MSS_MAC_BY8_PHY_CLK                         ( (uint8_t)(0x03) )
#define MSS_MAC_BY10_PHY_CLK                        ( (uint8_t)(0x04) )
#define MSS_MAC_BY14_PHY_CLK                        ( (uint8_t)(0x05) )
#define MSS_MAC_BY20_PHY_CLK                        ( (uint8_t)(0x06) )
#define MSS_MAC_BY28_PHY_CLK                        ( (uint8_t)(0x07) )

/* Default & Maximum PHY addresses */
#define MSS_MAC_DEFAULT_PHY                         ( DP83848 )
#define MSS_MAC_PHYADDR_MAXVAL                      ( (uint8_t)(0x1F) )
#define MSS_MAC_PHYREGADDR_MAXVAL                   ( (uint8_t)(0x1F) )
#define MSS_MAC_PHY_ADDR_DEFVAL                     ( (uint8_t)(0x00) )
#define MSS_MAC_PHYREGADDR_DEFVAL                   ( (uint8_t)(0x00) )

/* Maximum frame length default & maximum values */
#define MSS_MAC_MAXFRAMELEN_DEFVAL                  ( (uint16_t)(0x0600) )
#define MSS_MAC_MAXFRAMELEN_MAXVAL                  ( (uint16_t)(0x0600) )

/* Slottime (Collision window) default & maximum values */
#define MSS_MAC_SLOTTIME_DEFVAL                     ( (uint16_t)(0x0037) )
#define MSS_MAC_SLOTTIME_MAXVAL                     ( (uint16_t)(0x03FF) )

/* Frame drop mask default value */                                         
#define MSS_MAC_FRAME_DROP_MASK_DEFVAL      (        (uint32_t)(0x00000000) )

/*
 * Options for speed configuration.
 */
#define MSS_MAC_ANEG_10M_FD             0x00000001u
#define MSS_MAC_ANEG_10M_HD             0x00000002u
#define MSS_MAC_ANEG_100M_FD            0x00000004u
#define MSS_MAC_ANEG_100M_HD            0x00000008u
#define MSS_MAC_ANEG_1000M_FD           0x00000010u
#define MSS_MAC_ANEG_1000M_HD           0x00000020u
#define MSS_MAC_ANEG_ALL_SPEEDS         (MSS_MAC_ANEG_10M_FD | MSS_MAC_ANEG_10M_HD | \
                                         MSS_MAC_ANEG_100M_FD | MSS_MAC_ANEG_100M_HD | \
                                         MSS_MAC_ANEG_1000M_FD | MSS_MAC_ANEG_1000M_HD)

#define MSS_MAC_FORCE_10M_FD            MSS_MAC_ANEG_10M_FD
#define MSS_MAC_FORCE_10M_HD            MSS_MAC_ANEG_10M_HD
#define MSS_MAC_FORCE_100M_FD           MSS_MAC_ANEG_100M_FD
#define MSS_MAC_FORCE_100M_HD           MSS_MAC_ANEG_100M_HD
#define MSS_MAC_FORCE_1000M_FD          MSS_MAC_ANEG_1000M_FD
#define MSS_MAC_FORCE_1000M_HD          MSS_MAC_ANEG_1000M_HD

///////
/*------------------------------------------------------------------------------
 * MII register definitions.
 */
/* Generic MII registers. */
#define MII_BMCR                0x00u       /* Basic mode control register */
#define MII_BMSR                0x01u       /* Basic mode status register  */
#define MII_PHYSID1             0x02u       /* PHYS ID 1                   */
#define MII_PHYSID2             0x03u       /* PHYS ID 2                   */
#define MII_ADVERTISE           0x04u       /* Advertisement control reg   */
#define MII_LPA                 0x05u       /* Link partner ability reg    */
#define MII_EXPANSION           0x06u       /* Expansion register          */
#define MII_NPAR                    0x07u      
#define MII_LPNPA                   0x08u       
#define MII_CTRL1000            0x09u       /* 1000BASE-T control          */
#define MII_STAT1000            0x0au       /* 1000BASE-T status           */
#define MII_ESTATUS             0x0fu       /* Extended Status */
#define MII_DCOUNTER            0x12u       /* Disconnect counter          */
#define MII_FCSCOUNTER          0x13u       /* False carrier counter       */
#define MII_EXTEND              0x14u       /* extended PHY specific ctrl  */
#define MII_RERRCOUNTER         0x15u       /* Receive error counter       */
#define MII_SREVISION           0x16u       /* Silicon revision            */
#define MII_RESV1               0x17u       /* Reserved...                 */
#define MII_LBRERROR            0x18u       /* Lpback, rx, bypass error    */
#define MII_PHYADDR             0x19u       /* PHY address                 */
#define MII_RESV2               0x1au       /* Reserved...                 */
#define MII_TPISTATUS           0x1bu       /* TPI status for 10mbps       */
#define MII_NCONFIG             0x1cu       /* Network interface config    */
#define MII_LMCS                0x1du       
#define MII_PHYCTRL1            0x1eu       
#define MII_PHYCTRL2            0x1fu       

/* Basic mode control register. */
#define BMCR_RESV               0x003fu     /* Unused...                   */
#define BMCR_SPEED1000          0x0040u     /* MSB of Speed (1000)         */
#define BMCR_CTST               0x0080u     /* Collision test              */
#define BMCR_FULLDPLX           0x0100u     /* Full duplex                 */
#define BMCR_ANRESTART          0x0200u     /* Auto negotiation restart    */
#define BMCR_ISOLATE            0x0400u     /* Disconnect DP83840 from MII */
#define BMCR_PDOWN              0x0800u     /* Powerdown the DP83840       */
#define BMCR_ANENABLE           0x1000u     /* Enable auto negotiation     */
#define BMCR_SPEED100           0x2000u     /* Select 100Mbps              */
#define BMCR_LOOPBACK           0x4000u     /* TXD loopback bits           */
#define BMCR_RESET              0x8000u     /* Reset the DP83840           */


/* Basic mode status register. */
#define BMSR_ERCAP              0x0001u     /* Ext-reg capability          */
#define BMSR_JCD                0x0002u     /* Jabber detected             */
#define BMSR_LSTATUS            0x0004u     /* Link status                 */
#define BMSR_ANEGCAPABLE        0x0008u     /* Able to do auto-negotiation */
#define BMSR_RFAULT             0x0010u     /* Remote fault detected       */
#define BMSR_ANEGCOMPLETE       0x0020u     /* Auto-negotiation complete   */
#define BMSR_RESV               0x00c0u     /* Unused...                   */
#define BMSR_ESTATEN            0x0100u     /* Extended Status in R15 */
#define BMSR_100HALF2           0x0200u     /* Can do 100BASE-T2 HDX */
#define BMSR_100FULL2           0x0400u     /* Can do 100BASE-T2 FDX */
#define BMSR_10HALF             0x0800u     /* Can do 10mbps, half-duplex  */
#define BMSR_10FULL             0x1000u     /* Can do 10mbps, full-duplex  */
#define BMSR_100HALF            0x2000u     /* Can do 100mbps, half-duplex */
#define BMSR_100FULL            0x4000u     /* Can do 100mbps, full-duplex */
#define BMSR_100BASE4           0x8000u     /* Can do 100mbps, 4k packets  */

/* Advertisement control register. */
#define ADVERTISE_SLCT          0x001fu     /* Selector bits               */
#define ADVERTISE_CSMA          0x0001u     /* Only selector supported     */
#define ADVERTISE_10HALF        0x0020u     /* Try for 10mbps half-duplex  */
#define ADVERTISE_1000XFULL     0x0020u     /* Try for 1000BASE-X full-duplex */
#define ADVERTISE_10FULL        0x0040u     /* Try for 10mbps full-duplex  */
#define ADVERTISE_1000XHALF     0x0040u     /* Try for 1000BASE-X half-duplex */
#define ADVERTISE_100HALF       0x0080u     /* Try for 100mbps half-duplex */
#define ADVERTISE_1000XPAUSE    0x0080u     /* Try for 1000BASE-X pause    */
#define ADVERTISE_100FULL       0x0100u     /* Try for 100mbps full-duplex */
#define ADVERTISE_1000XPSE_ASYM 0x0100u     /* Try for 1000BASE-X asym pause */
#define ADVERTISE_100BASE4      0x0200u     /* Try for 100mbps 4k packets  */
#define ADVERTISE_PAUSE_CAP     0x0400u     /* Try for pause               */
#define ADVERTISE_PAUSE_ASYM    0x0800u     /* Try for asymetric pause     */
#define ADVERTISE_RESV          0x1000u     /* Unused...                   */
#define ADVERTISE_RFAULT        0x2000u     /* Say we can detect faults    */
#define ADVERTISE_LPACK         0x4000u     /* Ack link partners response  */
#define ADVERTISE_NPAGE         0x8000u     /* Next page bit               */

#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
                        ADVERTISE_CSMA)
#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
                       ADVERTISE_100HALF | ADVERTISE_100FULL)

* Link partner ability register. */
#define LPA_SLCT                0x001fu     /* Same as advertise selector  */
#define LPA_10HALF              0x0020u     /* Can do 10mbps half-duplex   */
#define LPA_1000XFULL           0x0020u     /* Can do 1000BASE-X full-duplex */
#define LPA_10FULL              0x0040u     /* Can do 10mbps full-duplex   */
#define LPA_1000XHALF           0x0040u     /* Can do 1000BASE-X half-duplex */
#define LPA_100HALF             0x0080u     /* Can do 100mbps half-duplex  */
#define LPA_1000XPAUSE          0x0080u     /* Can do 1000BASE-X pause     */
#define LPA_100FULL             0x0100u     /* Can do 100mbps full-duplex  */
#define LPA_1000XPAUSE_ASYM     0x0100u     /* Can do 1000BASE-X pause asym*/
#define LPA_100BASE4            0x0200u     /* Can do 100mbps 4k packets   */
#define LPA_PAUSE_CAP           0x0400u     /* Can pause                   */
#define LPA_PAUSE_ASYM          0x0800u     /* Can pause asymetrically     */
#define LPA_RESV                0x1000u     /* Unused...                   */
#define LPA_RFAULT              0x2000u     /* Link partner faulted        */
#define LPA_LPACK               0x4000u     /* Link partner acked us       */
#define LPA_NPAGE               0x8000u     /* Next page bit               */

#define LPA_DUPLEX              (LPA_10FULL | LPA_100FULL)
#define LPA_100                 (LPA_100FULL | LPA_100HALF | LPA_100BASE4)

/* Expansion register for auto-negotiation. */
#define EXPANSION_NWAY          0x0001u     /* Can do N-way auto-nego      */
#define EXPANSION_LCWP          0x0002u     /* Got new RX page code word   */
#define EXPANSION_ENABLENPAGE   0x0004u     /* This enables npage words    */
#define EXPANSION_NPCAPABLE     0x0008u     /* Link partner supports npage */
#define EXPANSION_MFAULTS       0x0010u     /* Multiple faults detected    */
#define EXPANSION_RESV          0xffe0u     /* Unused...                   */

#define ESTATUS_1000_TFULL      0x2000u     /* Can do 1000BT Full */
#define ESTATUS_1000_THALF      0x1000u     /* Can do 1000BT Half */

/* N-way test register. */
#define NWAYTEST_RESV1          0x00ffu     /* Unused...                   */
#define NWAYTEST_LOOPBACK       0x0100u     /* Enable loopback for N-way   */
#define NWAYTEST_RESV2          0xfe00u     /* Unused...                   */

/* 1000BASE-T Control register */
#define ADVERTISE_1000FULL      0x0200u     /* Advertise 1000BASE-T full duplex */
#define ADVERTISE_1000HALF      0x0100u     /* Advertise 1000BASE-T half duplex */

/* 1000BASE-T Status register */
#define LPA_1000LOCALRXOK       0x2000u     /* Link partner local receiver status */
#define LPA_1000REMRXOK         0x1000u     /* Link partner remote receiver status */
#define LPA_1000FULL            0x0800u     /* Link partner 1000BASE-T full duplex */
#define LPA_1000HALF            0x0400u     /* Link partner 1000BASE-T half duplex */

/* Indicates what features are supported by the interface. */
#define SUPPORTED_10baseT_Half          (1 << 0)
#define SUPPORTED_10baseT_Full          (1 << 1)
#define SUPPORTED_100baseT_Half         (1 << 2)
#define SUPPORTED_100baseT_Full         (1 << 3)
#define SUPPORTED_1000baseT_Half        (1 << 4)
#define SUPPORTED_1000baseT_Full        (1 << 5)
#define SUPPORTED_Autoneg               (1 << 6)
#define SUPPORTED_TP                    (1 << 7)
#define SUPPORTED_AUI                   (1 << 8)
#define SUPPORTED_MII                   (1 << 9)
#define SUPPORTED_FIBRE                 (1 << 10)
#define SUPPORTED_BNC                   (1 << 11)
#define SUPPORTED_10000baseT_Full       (1 << 12)
#define SUPPORTED_Pause                 (1 << 13)
#define SUPPORTED_Asym_Pause            (1 << 14)
#define SUPPORTED_2500baseX_Full        (1 << 15)
#define SUPPORTED_Backplane             (1 << 16)
#define SUPPORTED_1000baseKX_Full       (1 << 17)
#define SUPPORTED_10000baseKX4_Full     (1 << 18)
#define SUPPORTED_10000baseKR_Full      (1 << 19)
#define SUPPORTED_10000baseR_FEC        (1 << 20)

/* Indicates what features are advertised by the interface. */
#define ADVERTISED_10baseT_Half         (1 << 0)
#define ADVERTISED_10baseT_Full         (1 << 1)
#define ADVERTISED_100baseT_Half        (1 << 2)
#define ADVERTISED_100baseT_Full        (1 << 3)
#define ADVERTISED_1000baseT_Half       (1 << 4)
#define ADVERTISED_1000baseT_Full       (1 << 5)
#define ADVERTISED_Autoneg              (1 << 6)
#define ADVERTISED_TP                   (1 << 7)
#define ADVERTISED_AUI                  (1 << 8)
#define ADVERTISED_MII                  (1 << 9)
#define ADVERTISED_FIBRE                (1 << 10)
#define ADVERTISED_BNC                  (1 << 11)
#define ADVERTISED_10000baseT_Full      (1 << 12)
#define ADVERTISED_Pause                (1 << 13)
#define ADVERTISED_Asym_Pause           (1 << 14)
#define ADVERTISED_2500baseX_Full       (1 << 15)
#define ADVERTISED_Backplane            (1 << 16)
#define ADVERTISED_1000baseKX_Full      (1 << 17)
#define ADVERTISED_10000baseKX4_Full    (1 << 18)
#define ADVERTISED_10000baseKR_Full     (1 << 19)
#define ADVERTISED_10000baseR_FEC       (1 << 20)




/////


void cmd_sgmmi_init(int speed)
{
  int i;

  printf("\r\n cmd_sgmmi_init(%d)\r\n", speed);

  // init reset lines
  
  //////
  //////MSS_GPIO_init();
  //////
  uint32_t inc;
  uint32_t irq_number;
  uint32_t gpio_setting;

  /* reset MSS GPIO hardware */
  M2S_SYSREG->soft_reset_cr |= SYSREG_GPIO_SOFTRESET_MASK;
  M2S_SYSREG->soft_reset_cr |= (SYSREG_GPIO_7_0_SOFTRESET_MASK |
				SYSREG_GPIO_15_8_SOFTRESET_MASK |
				SYSREG_GPIO_23_16_SOFTRESET_MASK |
				SYSREG_GPIO_31_24_SOFTRESET_MASK);
  
  /* Clear any previously pended MSS GPIO interrupt */
  for(inc = 0U; inc < NB_OF_GPIO; ++inc)
    {
      irq_number = 50+inc; ///50 - 81
      //NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
      NVIC->ICER[irq_number>>5] = (1 << (irq_number & 0x1F));
      //NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
      NVIC->ICPR[irq_number>>5] = (1 <<(irq_number & 0x1F));
    }
  /* Take MSS GPIO hardware out of reset. */
  M2S_SYSREG->soft_reset_cr &= ~(SYSREG_GPIO_7_0_SOFTRESET_MASK |
				 SYSREG_GPIO_15_8_SOFTRESET_MASK |
				 SYSREG_GPIO_23_16_SOFTRESET_MASK |
				 SYSREG_GPIO_31_24_SOFTRESET_MASK);
  M2S_SYSREG->soft_reset_cr &= ~SYSREG_GPIO_SOFTRESET_MASK;
  ///////
  ///////
  ///////

  ///
  //MSS_GPIO_config(MSS_GPIO_0, MSS_GPIO_OUTPUT_MODE);
  ///
  *(g_config_reg_lut[0]) = MSS_GPIO_OUTPUT_MODE;
  
  ///
  ///MSS_GPIO_config(MSS_GPIO_1, MSS_GPIO_OUTPUT_MODE);
  ///
  *(g_config_reg_lut[1]) = MSS_GPIO_OUTPUT_MODE;

  // reset SERDESIF and Marvell
  ///
  ///MSS_GPIO_set_output(MSS_GPIO_1, 1); // release SERDESIF
  ///
  gpio_setting = GPIO->GPIO_OUT;
  gpio_setting &= ~((uint32_t)0x01u << 1);
  gpio_setting |= ((uint32_t)1 & 0x01u) << 1;
  GPIO->GPIO_OUT = gpio_setting;
  udelay(100000);

  //MSS_GPIO_set_output(MSS_GPIO_0, 1); // release Marvell
  gpio_setting = GPIO->GPIO_OUT;
  gpio_setting &= ~((uint32_t)0x01u << 0);
  gpio_setting |= ((uint32_t)1 & 0x01u) << 0;
  GPIO->GPIO_OUT = gpio_setting;
  //wait_x_miliseconds(200); // wait 200 ms
  udelay(200000);

  //////////////////////////////////////////////////////////////
  // configure MAC - TBI
  //NVIC_SetPriority(EthernetMAC_IRQn, 5); // configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY = 5;
  NVIC->IP[EthernetMAC_IRQn] = ((5 << (8 - 4)) & 0xFF); /// #define __NVIC_PRIO_BITS          4

  // MAC init from lwip-1.4.1
  //MSS_MAC_cfg_struct_def_init(&g_mac_config);
  {
    g_mac_config.speed_duplex_select = MSS_MAC_ANEG_ALL_SPEEDS;
    g_mac_config.phy_addr           = 0u;
    g_mac_config.interface          = MII;
    g_mac_config.tx_edc_enable      = MSS_MAC_ERR_DET_CORR_ENABLE;
    g_mac_config.rx_edc_enable      = MSS_MAC_ERR_DET_CORR_ENABLE;
    g_mac_config.preamble_length    = MSS_MAC_PREAMLEN_DEFVAL;
    g_mac_config.hugeframe_enable   = MSS_MAC_HUGE_FRAME_DISABLE;
    g_mac_config.length_field_check = MSS_MAC_LENGTH_FILED_CHECK_ENABLE;
    g_mac_config.pad_n_CRC          = MSS_MAC_PAD_N_CRC_ENABLE;
    g_mac_config.append_CRC         = MSS_MAC_CRC_ENABLE;
    g_mac_config.fullduplex         = MSS_MAC_FULLDUPLEX_ENABLE;
    g_mac_config.loopback           = MSS_MAC_LOOPBACK_DISABLE;
    g_mac_config.rx_flow_ctrl       = MSS_MAC_RX_FLOW_CTRL_ENABLE;
    g_mac_config.tx_flow_ctrl       = MSS_MAC_TX_FLOW_CTRL_ENABLE;
    g_mac_config.min_IFG            = MSS_MAC_MINIFG_DEFVAL;
    g_mac_config.btb_IFG            = MSS_MAC_BTBIFG_DEFVAL;
    g_mac_config.max_retx_tries     = MSS_MAC_MAXRETX_DEFVAL;
    g_mac_config.excessive_defer    = MSS_MAC_EXSS_DEFER_DISABLE;
    g_mac_config.nobackoff          = MSS_MAC_NO_BACKOFF_DISABLE;
    g_mac_config.backpres_nobackoff = MSS_MAC_BACKPRESS_NO_BACKOFF_DISABLE;
    g_mac_config.ABEB_enable        = MSS_MAC_ABEB_DISABLE;
    g_mac_config.ABEB_truncvalue    = MSS_MAC_ABEBTRUNC_DEFVAL;
    g_mac_config.phyclk             = MSS_MAC_DEF_PHY_CLK;
    g_mac_config.supress_preamble   = MSS_MAC_SUPPRESS_PREAMBLE_DISABLE;
    g_mac_config.autoscan_phys      = MSS_MAC_PHY_AUTOSCAN_DISABLE;
    g_mac_config.max_frame_length   = MSS_MAC_MAXFRAMELEN_DEFVAL;
    g_mac_config.non_btb_IFG        = MSS_MAC_NONBTBIFG_DEFVAL;
    g_mac_config.slottime           = MSS_MAC_SLOTTIME_DEFVAL;
    g_mac_config.framedrop_mask     = MSS_MAC_FRAME_DROP_MASK_DEFVAL;
        
    g_mac_config.mac_addr[0] = 0xC0;
    g_mac_config.mac_addr[1] = 0xB1;
    g_mac_config.mac_addr[2] = 0x3C;
    g_mac_config.mac_addr[3] = 0x88;
    g_mac_config.mac_addr[4] = 0x88;
    g_mac_config.mac_addr[5] = 0x88;

  }


  g_mac_config.interface = TBI;
  g_mac_config.phy_addr = 0u; // M88E1111_PHY_ADDR;
  g_mac_config.phyclk = MSS_MAC_BY28_PHY_CLK;
  g_mac_config.speed_duplex_select = (speed == 10) ? MSS_MAC_ANEG_10M_FD : MSS_MAC_ANEG_100M_FD;
  //if (g_sgmii_lb_mac) g_mac_config.loopback = MSS_MAC_LOOPBACK_ENABLE;
  g_mac_config.rx_flow_ctrl = MSS_MAC_RX_FLOW_CTRL_DISABLE;
  g_mac_config.tx_flow_ctrl = MSS_MAC_TX_FLOW_CTRL_DISABLE;
  //0x00, 0x18, 0xF3, 0xF4, 0x79, 0xDC, // src mac 00-18-F3-F4-79-DC
  g_mac_config.mac_addr[0] = g_rcu2_mac_addr[0] = 0x00;
  g_mac_config.mac_addr[1] = g_rcu2_mac_addr[1] = 0x18;
  g_mac_config.mac_addr[2] = g_rcu2_mac_addr[2] = 0xF3;
  g_mac_config.mac_addr[3] = g_rcu2_mac_addr[3] = 0xF4;
  g_mac_config.mac_addr[4] = g_rcu2_mac_addr[4] = 0x79;
  g_mac_config.mac_addr[5] = g_rcu2_mac_addr[5] = 0xDE;
  g_rcu2_ip_addr[0] = 10;
  g_rcu2_ip_addr[1] = 1;
  g_rcu2_ip_addr[2] = 5;
  g_rcu2_ip_addr[3] = 222;
  MSS_MAC_init(&g_mac_config);

  // wait for the auto-negotiation end
  for (i=0; i<200; i++) {
    MSS_MAC_get_link_status(NULL, NULL);
    uint16_t phy_1e_reg_01 = MSS_MAC_read_phy_reg(0x1E, 1);
    printf("%d, phy_1e_reg_01 = %04x\r\n", i, (int)phy_1e_reg_01);
    if (phy_1e_reg_01 & 0x4) break;
    //wait_x_miliseconds(100);
    udelay(1000000);
  }

  udelay(2000000);//  wait_x_miliseconds(200); // wait 200 ms

  // enable PHY crc and packet counter
  MSS_MAC_write_phy_reg(0x00, 29, 0x10);
  uint16_t reg30 = MSS_MAC_read_phy_reg(0x00, 30);
  MSS_MAC_write_phy_reg(0x00, 30, (reg30 & 0xfffe) | 0x0001);

  // disable the MSS-MAC interrupts
  MAC->DMA_IRQ_MASK = 0;
}

static void m2s_eth_recv(void *pkt)
{
  if ((MAC->DMA_RX_CTRL & M2S_MAC_DMA_CTRL_ENA) == 0)
    {
      m2s_bd_rx[0].frame = pkt;
      m2s_bd_rx[0].cfg_size = M2S_BD_EMPTY;
      m2s_bd_rx[0].next = (struct m2s_eth_dma_bd *)m2s_bd_rx;
      MAC->DMA_RX_DESC = (uint32_t)m2s_bd_rx;
      MAC->DMA_RX_CTRL = M2S_MAC_DMA_CTRL_ENA;
    }
}

void MSS_MAC_init(MAC_cfg_t *cfg){


  //NVIC_DisableIRQ(EthernetMAC_IRQn);
  NVIC->ICER[ (EthernetMAC_IRQn >> 5) ] = (1 << ((uint32_t) EthernetMAC_IRQn & 0x1F));

  /////
  ///mac_reset();
  ////
  {
    /* Reset MCXMAC TX functionality */
    set_bit_reg32( &MAC->CFG1, CFG1_TX_RST);
    /* Reset MCXMAC RX functionality */
    set_bit_reg32( &MAC->CFG1, CFG1_RX_RST);
    /* Reset MCXMAC TX control */
    set_bit_reg32( &MAC->CFG1, CFG1_TXCTL_RST);
    /* Reset MCXMAC RX control */
    set_bit_reg32( &MAC->CFG1, CFG1_RXCTL_RST);
    /* Reset MCXMAC interface control */
    set_bit_reg32( &MAC->INTERFACE_CTRL, MII_INTF_RESET);
    /* Reset FIFO watermark module */
    set_bit_reg32( &MAC->FIFO_CFG0, FIFO_CFG0_WMM_RST);
    /* Reset FIFO Rx system module */
    set_bit_reg32( &MAC->FIFO_CFG0, FIFO_CFG0_RSYS_RST);
    /* Reset FIFO Rx fab module */
    set_bit_reg32( &MAC->FIFO_CFG0, FIFO_CFG0_RFAB_RST);
    /* Reset FIFO Tx system module */
    set_bit_reg32( &MAC->FIFO_CFG0, FIFO_CFG0_TSYS_RST);
    /* Reset FIFO Tx system module */
    set_bit_reg32( &MAC->FIFO_CFG0, FIFO_CFG0_TFAB_RST);
  }
  //NVIC_ClearPendingIRQ(EthernetMAC_IRQn);
  NVIC->ICPR[ (EthernetMAC_IRQn >> 5) ] = (1 << ((uint32_t) EthernetMAC_IRQn & 0x1F));


  config_mac_hw(cfg);
        
  /* Assign MAC station address */
  assign_station_addr(cfg->mac_addr);

  /* Intialize Tx & Rx descriptor rings */
  tx_desc_ring_init();
  rx_desc_ring_init();

  /* Initialize Tx descriptors related variables. */
  g_mac.first_tx_index = INVALID_INDEX;
  g_mac.last_tx_index = INVALID_INDEX;
  g_mac.next_tx_index = 0;
  g_mac.nb_available_tx_desc = MSS_MAC_TX_RING_SIZE;
        
  /* Initialize Rx descriptors related variables. */
  g_mac.nb_available_rx_desc = MSS_MAC_RX_RING_SIZE;
  g_mac.next_free_rx_desc_index = 0;
  g_mac.first_rx_desc_index = INVALID_INDEX;
        
  /* initialize default interrupt handlers */
  g_mac.tx_complete_handler = NULL_POINTER;
  g_mac.pckt_rx_callback = NULL_POINTER;
        
  /* Initialize PHY interface */
  phy_init(cfg);
  phy_set_link_speed(cfg->speed_duplex_select);
  phy_autonegotiate();
  update_mac_cfg();
        
  /* Enable transmission at MAC level. */
  set_bit_reg32( &MAC->CFG1, CFG1_TX_EN);
  /* Enable reception at MAC level.    */
  set_bit_reg32( &MAC->CFG1, CFG1_RX_EN);
        
  /* Enable Tx Packet interrupt */
  set_bit_reg32(&MAC->DMA_IRQ_MASK, MSS_MAC_TXPKTSENT_IRQ);
  /* Enable RX Packet interrupt */
  set_bit_reg32(&MAC->DMA_IRQ_MASK, MSS_MAC_RXPKTRCVD_IRQ);

}

#define BITBAND(addr,bitnum)    (((uint32_t)addr & 0xF0000000)+0x02000000+(((uint32_t)addr & 0xFFFFF)<<5)+(bitnum<<2))
#define HW_REG_BIT(reg,bitnum)  (*(volatile unsigned int *)((BITBAND(reg,bitnum))))

static void set_bit_reg32(volatile uint32_t * reg, uint8_t bit)
{
  HW_REG_BIT(reg,bit) = 0x1;
}

static void clear_bit_reg32(volatile uint32_t * reg, uint8_t bit)
{
  HW_REG_BIT(reg,bit) = 0x0;
}

static void config_mac_hw(const MAC_cfg_t * cfg)
{
  uint32_t tempreg;
  /*--------------------------------------------------------------------------
   * Configure MAC FIFOs error detection and correction (EDAC)
   */
  /* Tx FIFO EDAC configuration */
  if(MSS_MAC_ENABLE == cfg->tx_edc_enable)
    {
      set_bit_reg32(&SYSREG->EDAC_CR, MAC_EDAC_TX_EN);
    }
  else
    {
      clear_bit_reg32(&SYSREG->EDAC_CR, MAC_EDAC_TX_EN);
    }
  /* Rx FIFO EDAC configuration */
  if(MSS_MAC_ENABLE == cfg->rx_edc_enable)
    {
      set_bit_reg32(&SYSREG->EDAC_CR,MAC_EDAC_RX_EN);
    }
  else
    {
      clear_bit_reg32(&SYSREG->EDAC_CR,MAC_EDAC_RX_EN);
    }
    
  /*--------------------------------------------------------------------------
   * Configure PHY related MII MGMT registers
   */
  tempreg = (uint32_t)cfg->phyclk & MII_CLOCK_SELECT_MASK;
  if(MSS_MAC_ENABLE == cfg->supress_preamble)
    {
      tempreg |= MII_PREAM_SUPRESS_MASK;
    }
    
  if(MSS_MAC_ENABLE == cfg->autoscan_phys)
    {
      tempreg |= MII_SCAN_AUTO_INC_MASK;
    }
  MAC->MII_CONFIG = tempreg;

  /*--------------------------------------------------------------------------
   * Clear all reset bits
   */              
  /* Clear soft reset for MCXMAC, Tx function, Rx function, Tx MAC control and
   * Rx MAC control. */
  MAC->CFG1 &= ~(CFG1_SOFT_RST_MASK | CFG1_TXCTL_RST_MASK |
                   CFG1_RXCTL_RST_MASK | CFG1_CFG1_TX_RST_MASK |
		 CFG1_CFG1_RX_RST_MASK);
    
  /* Clear MCXMAC interface reset. */
  clear_bit_reg32( &MAC->INTERFACE_CTRL, MII_INTF_RESET);
    
  /* Clear FIFO resets. */
  MAC->FIFO_CFG0 &= ~(FIFO_CFG0_WMM_RST_MASK | FIFO_CFG0_RSYS_RST_MASK |
                        FIFO_CFG0_RFAB_RST_MASK | FIFO_CFG0_TSYS_RST_MASK |
		      FIFO_CFG0_TFAB_RST_MASK);

  /*--------------------------------------------------------------------------
   * configure loppback and flow control enables.
   */
  if(MSS_MAC_ENABLE == cfg->loopback)
    {
      tempreg = CFG1_LOOPBACK_MASK;
    }
  else
    {
      tempreg = 0u;
    }
    
  if(MSS_MAC_ENABLE == cfg->rx_flow_ctrl)
    {
      tempreg |= CFG1_RX_FCTL_MASK;
    }
    
  if(MSS_MAC_ENABLE == cfg->tx_flow_ctrl)
    {
      tempreg |= CFG1_TX_FCTL_MASK;
    }
  MAC->CFG1 = tempreg;

  /*--------------------------------------------------------------------------
   *
   */
  if(MSS_MAC_ENABLE == cfg->fullduplex)
    {
      tempreg = CFG2_FDX_MASK;
    }
  else
    {
      tempreg = 0u;
    }
    
  if(MSS_MAC_ENABLE == cfg->append_CRC)
    {
      tempreg |= CFG2_CRC_EN_MASK;
    }
                                   
  if(MSS_MAC_ENABLE == cfg->pad_n_CRC)
    {
      tempreg |= CFG2_PAD_CRC_EN_MASK;
    }
                                  
  if(MSS_MAC_ENABLE == cfg->length_field_check)
    {
      tempreg |= CFG2_LEN_CHECK_MASK;
    }
                                           
  if(MSS_MAC_ENABLE == cfg->hugeframe_enable)
    {
      tempreg |= CFG2_HUGE_FRAME_EN_MASK;
    }
                                         
  if((MII == cfg->interface) || (RMII == cfg->interface))
    {
      /* MII and RMII use nibble mode interface. */
      tempreg |= CFG2_NIBBLE_MASK;
    }
  else
    {
      /* TBI and GMII use byte interface. */
      tempreg |= CFG2_BYTE_MASK;
    }
  tempreg |= (((uint32_t)cfg->preamble_length ) << CFG2_PREAM_LEN);

  MAC->CFG2 = tempreg;
    
  /*--------------------------------------------------------------------------
   *
   */
  tempreg = cfg->btb_IFG;
  tempreg |= ( (uint32_t)cfg->min_IFG << IFG_MINIFGENF );
  tempreg |= ( (uint32_t)cfg->non_btb_IFG << IFG_NONBTBIPG );
  MAC->IFG = tempreg;
    
  /*--------------------------------------------------------------------------
   *
   */
  tempreg = (uint32_t)cfg->slottime & HALF_DUPLEX_SLOTTIME_MASK;
    
  tempreg |= (uint32_t)cfg->max_retx_tries << HALF_DUPLEX_RETX_MAX_OFFSET;
    
  if(MSS_MAC_ENABLE == cfg->excessive_defer)
    {
      tempreg |= HALF_DUPLEX_EXCS_DEFER_MASK;
    }
                                       
  if(MSS_MAC_ENABLE == cfg->nobackoff)
    {
      tempreg |= HALF_DUPLEX_NO_BACKOFF_MASK;
    }
                                       
  if(MSS_MAC_ENABLE == cfg->backpres_nobackoff)
    {
      tempreg |= HALF_DUPLEX_BACKPRES_NOBACKOFF_MASK;
    }
                                       
  if(MSS_MAC_ENABLE == cfg->ABEB_enable)
    {
      tempreg |= HALF_DUPLEX_ABEB_ENABLE_MASK;
    }
                                       
  tempreg |= (uint32_t)cfg->ABEB_truncvalue << HALF_DUPLEX_ABEB_TUNC_OFFSET;
  MAC->HALF_DUPLEX = tempreg;

  MAC->MAX_FRAME_LENGTH = (uint32_t)cfg->max_frame_length;

  /*--------------------------------------------------------------------------
   * Configure FIFOs
   */
  MAC->FIFO_CFG0 = ( FIFO_CFG0_WMM_ENABLE  | FIFO_CFG0_RSYS_ENABLE |
                       FIFO_CFG0_RFAB_ENABLE | FIFO_CFG0_TSYS_ENABLE |
		     FIFO_CFG0_TFAB_ENABLE );
  /* RX FIFO size : 8KB  */        
  MAC->FIFO_CFG1 = FIFO_CFG1_DEFVAL;
  /* Rx FIFO watermark */
  MAC->FIFO_CFG2 = FIFO_CFG2_DEFVAL;
  /* Tx FIFO watermark: 4KB Tx FIFO */
  MAC->FIFO_CFG3 = FIFO_CFG3_DEFVAL;
  /* Drop junk frames (Frames suffered CRC error or short collision) */
  MAC->FIFO_CFG4 = FIFO_CFG4_DEFVAL;
  /* Drop frames with CRC errors and PAUSE frames */
  MAC->FIFO_CFG5 = FIFO_CFG5_DEFVAL;
    
  /*--------------------------------------------------------------------------
   * Interface type: MII/GMII/RMII/TBI
   */
  M2S_SYSREG->mac_cr = ((uint32_t)cfg->interface) << MAC_CONFIG_INTF;
}


static void assign_station_addr(const uint8_t mac_addr[6])
{
  uint32_t address32;

  address32 = ((uint32_t)mac_addr[5]) << 24u;
  address32 |= ((uint32_t)mac_addr[4]) << 16u;
  address32 |= ((uint32_t)mac_addr[3]) << 8u;
  address32 |= ((uint32_t)mac_addr[2]);
  MAC->STATION_ADDRESS1 = address32;
  address32 = ((uint32_t)mac_addr[1]) << 24u;
  address32 |= ((uint32_t)mac_addr[0]) << 16u;
  MAC->STATION_ADDRESS2 = address32;
}

static void tx_desc_ring_init(void){
  int32_t inc;
  
  for(inc = 0; inc < MSS_MAC_TX_RING_SIZE; ++inc){
    g_mac.tx_desc_tab[inc].pkt_start_addr = 0u;
    g_mac.tx_desc_tab[inc].pkt_size = DMA_DESC_EMPTY_FLAG_MASK;
    if((MSS_MAC_TX_RING_SIZE - 1) == inc){
      g_mac.tx_desc_tab[inc].next_desriptor = &g_mac.tx_desc_tab[0];
    }
    else
      {
	g_mac.tx_desc_tab[inc].next_desriptor = &g_mac.tx_desc_tab[inc + 1];
      }
    g_mac.tx_desc_tab[inc].index = inc;
  }
}

static void rx_desc_ring_init(void){
  int32_t inc;
    
  for(inc = 0; inc < MSS_MAC_RX_RING_SIZE; ++inc){
    g_mac.rx_desc_tab[inc].pkt_start_addr = 0u;
    g_mac.rx_desc_tab[inc].pkt_size = 0u;
    if((MSS_MAC_RX_RING_SIZE - 1) == inc)
      {
	g_mac.rx_desc_tab[inc].next_desriptor = &g_mac.rx_desc_tab[0];
      }
    else
      {
	g_mac.rx_desc_tab[inc].next_desriptor = &g_mac.rx_desc_tab[inc + 1];
      }
    g_mac.rx_desc_tab[inc].index = inc;
  }
}


#define SF2_PHY_ADDR    0x1E
#define SF2_MSGMII_PHY_ADDR     0x1E
#define SF2_MSGMII_PHY_RESET_MASK  0x8000u

#define BMSR_AUTO_NEGOTIATION_COMPLETE  0x0020u

#define ANEG_REQUESTED          0x80000000u
#define FORCED_CFG_REQUESTED    0x40000000u

/*------------------------------------------------------------------------------
 * M88E1111 PHY specific register offsets and bit definitions
 */
#define M88E1111_EXT_ADDR_PAGE_CR       0x16
#define PAGE_0                          0x00
#define PAGE_1                          0x01

#define M88E1111_PHY_EXT_SR             0x1b

#define M88E1111_PHY_STATUS             0x11
#define M88E1111_PHY_STATUS_1000        0x8000
#define M88E1111_PHY_STATUS_100         0x4000
#define M88E1111_PHY_STATUS_SPD_MASK    0xc000
#define M88E1111_PHY_STATUS_FULLDUPLEX  0x2000
#define M88E1111_PHY_STATUS_RESOLVED    0x0800
#define M88E1111_PHY_STATUS_LINK        0x0400

#define M88E1111_PHY_SPEC_CTRL          16
#define M88E1111_PHY_SPEC_CTRL_MDIX_0   (1u << 5)
#define M88E1111_PHY_SPEC_CTRL_MDIX_1   (1u << 6)


/*------------------------------------------------------------------------------
 * G4M MAC Configuration system register 
 * Speed and interface configuration fields.
 */
#define MAC_CONFIG_SPEED              0u
#define MAC_CONFIG_INTF               2u
#define MAC_CONFIG_SPEED_MASK         ((uint32_t)0x03)
#define MAC_CONFIG_INTF_MASK          (7u << 2) 

/*------------------------------------------------------------------------------
 * G4M MAC Error detection and correction enable system register 
 * Fields of EDAC_ENABLE system register.
 */
#define MAC_EDAC_TX_EN                3u
#define MAC_EDAC_RX_EN                4u

/*------------------------------------------------------------------------------
 * G4M MAC Error detection and correction interrupt enable system register 
 * Fields of EDAC_INT_ENABLE system register.
 */
#define MAC_EDAC_TX_1E_EN             6u
#define MAC_EDAC_TX_2E_EN             7u
#define MAC_EDAC_RX_1E_EN             8u
#define MAC_EDAC_RX_2E_EN             9u

/*------------------------------------------------------------------------------
 * G4M MAC Error detection and correction counter system registers
 * Contain 1bit EDAC count (15:0) and 2bit EDAC count (31:16).
 * Masks for 1bit and 2bit counts
 */
#define MAC_1B_EDAC_TX_CNT             0xFFFFu
#define MAC_2B_EDAC_TX_CNT             (0xFFFFu << 16)
#define MAC_1B_EDAC_RX_CNT             0xFFFFu
#define MAC_2B_EDAC_RX_CNT             (0xFFFFu << 16)

/*------------------------------------------------------------------------------
 * G4M MAC Error detection and correction address system registers
 * Contain 1bit EDAC address (12:0) and 2bit EDAC address (26:13).
 * Masks for 1bit and 2bit counts
 */
#define MAC_EDAC_RX_1E_AD              0x1FFFu
#define MAC_EDAC_RX_2E_AD              (0x1FFFu << 13)
#define MAC_EDAC_TX_1E_AD              0x1FFFu
#define MAC_EDAC_TX_2E_AD              (0x1FFFu << 13)

/*------------------------------------------------------------------------------
 * G4M MAC Error detection and correction status system registers
 * Fields of EDAC_STATUS system register.
 */
#define MAC_EDAC_TX_1E_STATUS          6u
#define MAC_EDAC_TX_2E_STATUS          7u
#define MAC_EDAC_RX_1E_STATUS          8u
#define MAC_EDAC_RX_2E_STATUS          9u


/*------------------------------------------------------------------------------
 * G4M MAC Error detection and correction counter clear system registers
 * Fields of CLR_EDAC_COUNTERS system register.
 */
#define MAC_EDAC_TX_CNTCLR_1E          6u
#define MAC_EDAC_TX_CNTCLR_2E          7u
#define MAC_EDAC_RX_CNTCLR_1E          8u
#define MAC_EDAC_RX_CNTCLR_2E          9u


/*------------------------------------------------------------------------------
 * MAC Configuration register 1
 */
#define CFG1_SOFT_RST               31u
#define CFG1_RXCTL_RST              19u
#define CFG1_TXCTL_RST              18u
#define CFG1_RX_RST                 17u
#define CFG1_TX_RST                 16u
#define CFG1_LOOPBACK               8u
#define CFG1_RX_FCTL                5u
#define CFG1_TX_FCTL                4u
#define CFG1_RX_EN                  2u
#define CFG1_TX_EN                  0u
#define CFG1_SOFT_RST_MASK          ((uint32_t)1u << CFG1_SOFT_RST)
#define CFG1_RXCTL_RST_MASK         ((uint32_t)1u << CFG1_RXCTL_RST)
#define CFG1_TXCTL_RST_MASK         ((uint32_t)1u << CFG1_TXCTL_RST)
#define CFG1_CFG1_RX_RST_MASK       ((uint32_t)1u << CFG1_RX_RST)
#define CFG1_CFG1_TX_RST_MASK       ((uint32_t)1u << CFG1_TX_RST)
#define CFG1_LOOPBACK_MASK          ((uint32_t)1u << CFG1_LOOPBACK)
#define CFG1_RX_FCTL_MASK           ((uint32_t)1u << CFG1_RX_FCTL)
#define CFG1_TX_FCTL_MASK           ((uint32_t)1u << CFG1_TX_FCTL)
#define CFG1_RX_EN_MASK             ((uint32_t)1u << CFG1_RX_EN)
#define CFG1_TX_EN_MASK             ((uint32_t)1u)

/*------------------------------------------------------------------------------
 * MAC Configuration register 2
 */
#define CFG2_FDX                    0u
#define CFG2_CRC_EN                 1u
#define CFG2_PAD_CRC_EN             2u
#define CFG2_LEN_CHECK              4u
#define CFG2_HUGE_FRAME_EN          5u
#define CFG2_IF_1000                9u
#define CFG2_IF_10_100              8u
#define CFG2_PREAM_LEN              12u
#define CFG2_FDX_MASK               ((uint32_t)1u)
#define CFG2_CRC_EN_MASK            ((uint32_t)1u << 1)
#define CFG2_PAD_CRC_EN_MASK        ((uint32_t)1u << 2)
#define CFG2_LEN_CHECK_MASK         ((uint32_t)1u << 4)
#define CFG2_HUGE_FRAME_EN_MASK     ((uint32_t)1u << 5)
#define CFG2_BYTE_MASK              ((uint32_t)1u << 9)
#define CFG2_NIBBLE_MASK            ((uint32_t)1u << 8)

/*------------------------------------------------------------------------------
 * MAC IPG/IFG register
 */
#define IFG_BTBIPG                  0u
#define IFG_MINIFGENF               8u
#define IFG_NONBTBIPG               16u


/*------------------------------------------------------------------------------
 * MAC half-duplex register
 */
#define HALF_DUPLEX_SLOTTIME                  0u
#define HALF_DUPLEX_RETX_MAX_OFFSET           12u
#define HALF_DUPLEX_EXCS_DEFER_MASK           ((uint32_t)1u<<16)
#define HALF_DUPLEX_NO_BACKOFF_MASK           ((uint32_t)1u<<17)
#define HALF_DUPLEX_BACKPRES_NOBACKOFF_MASK   ((uint32_t)1u<<18)
#define HALF_DUPLEX_ABEB_ENABLE_MASK          ((uint32_t)1u<<19)
#define HALF_DUPLEX_ABEB_TUNC_OFFSET          20u

#define HALF_DUPLEX_SLOTTIME_MASK             ((uint32_t)0x2FF)

/*------------------------------------------------------------------------------
 * MAC MII Management configuration register
 */
#define MII_CLOCK_SELECT_MASK                 ((uint32_t)7u)
#define MII_PREAM_SUPRESS_MASK                ((uint32_t)1u << 4)
#define MII_SCAN_AUTO_INC_MASK                ((uint32_t)1u << 5)
#define MII_RESET_MII_MGMT_MASK               ((uint32_t)1u << 31)

/*------------------------------------------------------------------------------
 * MAC MII Management address register
 */
#define MII_PHY_ADDR                    8u
#define MII_PHY_ADDR_MASK               (0x1Fu<<8)
#define MII_INTF_RESET                  31u

/*------------------------------------------------------------------------------
 * MAC MII Management command register
 */
#define MII_READ                        0u
#define MII_SCAN                        1u

/*------------------------------------------------------------------------------
 * MAC MII Management indicators register
 */
#define MII_BUSY_INDICATOR_MASK         ((uint32_t)1u)
#define MII_SCAN_INDICATOR_MASK         ((uint32_t)1u << 1)
#define MII_NV_INDICATOR_MASK           ((uint32_t)1u << 2)

/*------------------------------------------------------------------------------
 * DMA Tx control & Rx control registers
 */
#define DMA_TXENABLE                    0u
#define DMA_RXENABLE                    0u

/*------------------------------------------------------------------------------
 * DMA Tx status register
 */
#define DMA_TXPKTSENT                   0u
#define DMA_TXUNDRRUN                   1u
#define DMA_TXBUSERR                    3u

/*------------------------------------------------------------------------------
 * DMA Rx status register
 */
#define DMA_RXPKTRCVD                   0u
#define DMA_RXOVRFLOW                   2u
#define DMA_RXBUSERR                    3u


/*------------------------------------------------------------------------------
 * DMA descriptor definitions
 */
#define DMA_DESC_EMPTY_FLAG_MASK        ((uint32_t)1u << 31u)
#define DMA_DESC_PKT_SIZE_MASK          0xFFFu

/*------------------------------------------------------------------------------
 * DMA descriptor packet size 
 */
#define DMA_PKTCOUNT                    16u
#define DMA_PKTCOUNT_MASK               ((uint32_t)0xFFu << 16)

/*------------------------------------------------------------------------------
 * FIFO control registers definitions
 */
#define FIFO_CFG0_WMM_RST               0u
#define FIFO_CFG0_RSYS_RST              1u
#define FIFO_CFG0_RFAB_RST              2u
#define FIFO_CFG0_TSYS_RST              3u
#define FIFO_CFG0_TFAB_RST              4u

#define FIFO_CFG0_WMM_RST_MASK          ((uint32_t)1u)
#define FIFO_CFG0_RSYS_RST_MASK         ((uint32_t)1u << FIFO_CFG0_RSYS_RST)
#define FIFO_CFG0_RFAB_RST_MASK         ((uint32_t)1u << FIFO_CFG0_RFAB_RST)
#define FIFO_CFG0_TSYS_RST_MASK         ((uint32_t)1u << FIFO_CFG0_TSYS_RST)
#define FIFO_CFG0_TFAB_RST_MASK         ((uint32_t)1u << FIFO_CFG0_TFAB_RST)

#define FIFO_CFG0_WMM_ENABLE            ((uint32_t)1u << 8)
#define FIFO_CFG0_RSYS_ENABLE           ((uint32_t)1u << 9)
#define FIFO_CFG0_RFAB_ENABLE           ((uint32_t)1u << 10)
#define FIFO_CFG0_TSYS_ENABLE           ((uint32_t)1u << 11)
#define FIFO_CFG0_TFAB_ENABLE           ((uint32_t)1u << 12)

#define FIFO_CFG5_CFGHDPLX_MASK         ((uint32_t)1u << 22)

#define FIFO_CFG1_DEFVAL                0x0FFF0000u
#define FIFO_CFG2_DEFVAL                0x04000180u
#define FIFO_CFG3_DEFVAL                0x0258FFFFu
#define FIFO_CFG4_DEFVAL                0x0000FFFFu
#define FIFO_CFG5_DEFVAL                0x0007EFEFu

/*------------------------------------------------------------------------------
 * Interface control register definitions
 */
#define INTERFACE_SPEED_MASK            ((uint32_t)1 << 16)

/*------------------------------------------------------------------------------
 * Interface status register definitions
 */
#define INF_PE10T_JABBER                (1u<<0)
#define INF_PE10T_SQE                   ((uint32_t)1 << 1)
#define INF_LOC                         ((uint32_t)1 << 2)
#define INF_LINK_FAIL                   ((uint32_t)1 << 3)
#define INF_SPEED                       ((uint32_t)1 << 4)
#define INF_FULL_DUPLEX                 ((uint32_t)1 << 5)
#define INF_SGMII_LINK_OK               ((uint32_t)1 << 6)
#define INF_SGMII_JABBER                ((uint32_t)1 << 7)
#define INF_SGMII_CLASH                 ((uint32_t)1 << 8)
#define INF_EXCS_DEFER                  ((uint32_t)1 << 9)
#define INF_WOLDTCTD                    ((uint32_t)1 << 10)

/*------------------------------------------------------------------------------
 * Receive Statistics Vectors
 */
#define RSV_UCAD_MASK                   ((uint32_t)1 << 17)




/***************************************************************************
//**
   * Address of the PHY on the MII management interface.
*/
static uint8_t g_phy_addr = 0u;

/**************************************************************************
//**
   * See m88e1111_phy.h for details of how to use this function.
*/
void phy_init(MAC_cfg_t * cfg){
  uint16_t phy_reg;
    
  g_phy_addr = cfg->phy_addr;
    
  if(TBI == cfg->interface)
    {
      MSS_MAC_write_phy_reg(SF2_MSGMII_PHY_ADDR, 0x04, 0x0001);
      /*
       * Enable auto-negotiation inside SmartFusion2 SGMII block.
       */
      phy_reg = MSS_MAC_read_phy_reg(SF2_MSGMII_PHY_ADDR, 0x00);
      phy_reg |= 0x1000;
      MSS_MAC_write_phy_reg(SF2_MSGMII_PHY_ADDR, 0x00, phy_reg);
    }
}


uint16_t MSS_MAC_read_phy_reg(uint8_t phyaddr, uint8_t regaddr)
{
  uint32_t timeout = 100000u;
  uint16_t read_val = 0u;

  /* 
   * Write PHY address in MII Mgmt address register.
   * Makes previous register address 0 & invalid.
   */ 
  if((MSS_MAC_PHYADDR_MAXVAL >= phyaddr) && 
     (MSS_MAC_PHYREGADDR_MAXVAL >= regaddr))
    {
      uint32_t mii_not_valid;
      uint32_t mii_busy;
      
      /* Wait for MII Mgmt interface to complete previous operation. */
      do {
	;
      } while((MAC->MII_INDICATORS & MII_BUSY_INDICATOR_MASK) != 0u);
        
      MAC->MII_ADDRESS = (((uint32_t)phyaddr) << MII_PHY_ADDR);
      /* Load PHY register address in MII Mgmt address register */
      MAC->MII_ADDRESS |= (uint32_t)regaddr;
      /* Issue read command to PHY */
      set_bit_reg32( &MAC->MII_COMMAND, MII_READ);
      /* Poll till PHY read cycle is completed or timeout expired */
      do {
	--timeout;
	mii_not_valid = MAC->MII_INDICATORS & MII_NV_INDICATOR_MASK;
	mii_busy = MAC->MII_INDICATORS & MII_BUSY_INDICATOR_MASK;
      } while((timeout > 0u) && ((mii_busy != 0u) || (mii_not_valid != 0u)));

      /* Read value from MII Mgmt status register only if timeout is not expired
	 but the read the read cycle is completed */
      if(timeout != 0u)
        {
	  read_val = (uint16_t)MAC->MII_STATUS;
        }
    }
  clear_bit_reg32(&MAC->MII_COMMAND, MII_READ);
  return read_val;
}


void MSS_MAC_write_phy_reg(uint8_t phyaddr, uint8_t regaddr, uint16_t regval)
{
  /* 
   * Write PHY address in MII Mgmt address register.
   * Makes previous register address 0 & invalid.
   */ 
  if((MSS_MAC_PHYADDR_MAXVAL >= phyaddr) && 
     (MSS_MAC_PHYREGADDR_MAXVAL >= regaddr)){
    /* Wait for MII Mgmt interface to complete previous operation. */
    do {
      ;
    } while(MAC->MII_INDICATORS & MII_BUSY_INDICATOR_MASK);
    
    /* Load PHY address in MII Mgmt address register */
    MAC->MII_ADDRESS = (((uint32_t)phyaddr)<<MII_PHY_ADDR);
    /* Load register address in MII Mgmt address register */
    MAC->MII_ADDRESS |= (uint32_t)regaddr;
    /* Load value to be written in MII Mgmt control register */
    MAC->MII_CTRL = (uint32_t)regval ;
  }
}


void phy_set_link_speed(uint32_t speed_duplex_select)
{
  uint16_t phy_reg;
  uint32_t inc;
  uint32_t speed_select;
  const uint16_t mii_advertise_bits[4] 
    = {ADVERTISE_10FULL, ADVERTISE_10HALF, ADVERTISE_100FULL, ADVERTISE_100HALF};
    
  /* Set auto-negotiation advertisement. */

#if 1
  // Marvell 88E1111 MDIX fix
  if (g_rcu2_phy_mdix_disable) {
    uint16_t phy_spec_ctrl = MSS_MAC_read_phy_reg(g_phy_addr, M88E1111_PHY_SPEC_CTRL);
    phy_spec_ctrl &= ~(M88E1111_PHY_SPEC_CTRL_MDIX_1 | M88E1111_PHY_SPEC_CTRL_MDIX_0); // clear MDIX
    //phy_spec_ctrl |= M88E1111_PHY_SPEC_CTRL_MDIX_1 | M88E1111_PHY_SPEC_CTRL_MDIX_0; // auto MDIX
    //phy_spec_ctrl |= M88E1111_PHY_SPEC_CTRL_MDIX_0; // force MDIX
    MSS_MAC_write_phy_reg(g_phy_addr, M88E1111_PHY_SPEC_CTRL, phy_spec_ctrl);
    uint16_t phy_bmcr = MSS_MAC_read_phy_reg(g_phy_addr, MII_BMCR);
    phy_bmcr |= BMCR_RESET;
    MSS_MAC_write_phy_reg(g_phy_addr, MII_BMCR, phy_bmcr);
    //printf("Marvell 88E1111 MDIX disabled.\n\r");
  }
#endif

  /* Set 10Mbps and 100Mbps advertisement. */
  phy_reg = MSS_MAC_read_phy_reg(g_phy_addr, MII_ADVERTISE);
  phy_reg &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
	       ADVERTISE_100HALF | ADVERTISE_100FULL);
                 
  speed_select = speed_duplex_select;
  for(inc = 0u; inc < 4u; ++inc){
    uint32_t advertise;
    advertise = speed_select & 0x00000001u;
    if(advertise != 0u){
      phy_reg |= mii_advertise_bits[inc];
    }
    speed_select = speed_select >> 1u;
  }
    
  MSS_MAC_write_phy_reg(g_phy_addr, MII_ADVERTISE, phy_reg);
  
  /* Set 1000Mbps advertisement. */
  phy_reg = MSS_MAC_read_phy_reg(g_phy_addr, MII_CTRL1000);
  phy_reg &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
    
  if((speed_duplex_select & MSS_MAC_ANEG_1000M_FD) != 0u)
    {
      phy_reg |= ADVERTISE_1000FULL;
    }
    
  if((speed_duplex_select & MSS_MAC_ANEG_1000M_HD) != 0u)
    {
      phy_reg |= ADVERTISE_1000HALF;
    }
    
  MSS_MAC_write_phy_reg(g_phy_addr, MII_CTRL1000, phy_reg);
}

void phy_autonegotiate(void)
{
  uint16_t phy_reg;
  uint16_t autoneg_complete;

  if (g_rcu2_phy_disable){
    return;
  }
    
  /* Enable auto-negotiation. */
  MSS_MAC_write_phy_reg(g_phy_addr, M88E1111_EXT_ADDR_PAGE_CR, PAGE_0);
  phy_reg = MSS_MAC_read_phy_reg(g_phy_addr, MII_BMCR);
  phy_reg = 0x9340;
  MSS_MAC_write_phy_reg(g_phy_addr, MII_BMCR, phy_reg);
    
  /* Wait for copper auto-negotiation to complete. */
  do {
    phy_reg = MSS_MAC_read_phy_reg(g_phy_addr, MII_BMSR);
    autoneg_complete = phy_reg & BMSR_AUTO_NEGOTIATION_COMPLETE;
  } while(!autoneg_complete);

}


static void update_mac_cfg(void)
{
  MAC_speed_t speed;
  uint8_t fullduplex;
  uint8_t link_up;
    
  link_up = phy_get_link_status(&speed, &fullduplex);
  if(link_up != 0u)
    {
      /* Reconfigure MAC based on PHY configuration. */
      if(MAC100MBPS == speed)
        {
	  MAC->INTERFACE_CTRL |= INTERFACE_SPEED_MASK;
        }
      else
        {
	  MAC->INTERFACE_CTRL &= ~INTERFACE_SPEED_MASK;
        }
        
      /* Set byte/nibble mode based on interface type and link speed. */
      if(MAC1000MBPS == speed)
        {
	  /* Set interface to byte mode. */
	  MAC->CFG2 &= ~(CFG2_BYTE_MASK | CFG2_NIBBLE_MASK);
	  MAC->CFG2 |= CFG2_BYTE_MASK;
        }
      else
        {
	  /* Set interface to nibble mode. */
	  MAC->CFG2 &= ~(CFG2_BYTE_MASK | CFG2_NIBBLE_MASK);
	  MAC->CFG2 |= CFG2_NIBBLE_MASK;
        }
        
      if(MAC10MBPS == speed)
        {
	  /* Avoid extra divide by 10 of clock for 10Mbps links. */
	  speed = MAC100MBPS;
        }
      M2S_SYSREG->mac_cr = (M2S_SYSREG->mac_cr & ~MAC_CONFIG_SPEED_MASK) | (uint32_t)speed;
        
      /* Configure duplex mode */
      if(0u == fullduplex)
        {
	  /* half duplex */
	  MAC->CFG2 &= ~CFG2_FDX_MASK;
	  MAC->FIFO_CFG5 |= FIFO_CFG5_CFGHDPLX_MASK;
        }
      else
        {
	  /* full duplex */
	  MAC->CFG2 |= CFG2_FDX_MASK;
	  MAC->FIFO_CFG5 &= ~FIFO_CFG5_CFGHDPLX_MASK;
        }
    }
}


uint8_t phy_get_link_status(MAC_speed_t * speed, uint8_t *     fullduplex)
{
  uint16_t phy_reg;
  uint16_t link_up;
  uint8_t link_status;
    
  if (g_rcu2_phy_disable)
    {
      *fullduplex = MSS_MAC_FULLDUPLEX_ENABLE;
      *speed = MAC100MBPS;
      return 1;
    }

  phy_reg = MSS_MAC_read_phy_reg(g_phy_addr, MII_BMSR);
  link_up = phy_reg & BMSR_LSTATUS;
    
  if(link_up != 0u)
    {
      uint16_t duplex;
      uint16_t phy_speed;
        
      /* Link is up. */
      link_status = 1u;
        
      phy_reg = MSS_MAC_read_phy_reg(g_phy_addr, M88E1111_PHY_STATUS);
      duplex = phy_reg & M88E1111_PHY_STATUS_FULLDUPLEX;
      phy_speed = phy_reg & M88E1111_PHY_STATUS_SPD_MASK;
        
      if(0u == duplex)
        {
	  *fullduplex = MSS_MAC_FULLDUPLEX_DISABLE;
        }
      else
        {
	  *fullduplex = MSS_MAC_FULLDUPLEX_ENABLE;
        }
        
      switch(phy_speed) 
        {
	case M88E1111_PHY_STATUS_1000:
	  *speed = MAC1000MBPS;
	  break;
    
	case M88E1111_PHY_STATUS_100:
	  *speed = MAC100MBPS;
	  break;
    
	default:
	  *speed = MAC10MBPS;
	  break;
        }
    }
  else
    {
      /* Link is down. */
      link_status = 0u;
    }
    
  return link_status;
}

