#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/time.h>
#include <linux/types.h>
#include <errno.h>
#include <sys/poll.h> 
#include <time.h>
#include <stdlib.h>
#include <string.h>

#define BCDDEZ(val) ((val & 0xf0) >> 4) * 10 + (val & 0xf)
#define DEZBCD(val) (((val) / 10) << 4) + ((val) % 10)
#define DEFAULTI2CADDR 42
//#define TESTMODE
/* const char i2cdev[]="/dev/i2c/081"; */
char pointerdev[]="/dev/i2c/XXX";
char registerdev[]="/dev/i2c/XXX";
const char ttcrxdev[]="/dev/i2c/ttcrx";
const char revision[]="$Rev$";
int fd_pointer;
int fd_register;



///////////////////////////////////////////////////
//
//  Check a I2C Address
//
int check_i2c(i2caddr) {
  char i2cdev[]="/dev/i2c/000";
  int verbose=0;
  int ret;
  int reg;
  int fd;

  sprintf(i2cdev+9,"%03u",(unsigned int) i2caddr);
  if (verbose > 1)
    printf("Probing for I2C device on address %3d -> opening %s",i2caddr,i2cdev);
  fd = open (i2cdev, O_RDWR);
  if(fd < 0) {
    perror(i2cdev);
    printf("Please make sure all /dev/i2c files are present\n");
    return -1;
  }
  // do test
  if (verbose > 1)
    printf(" -> reading one Byte\n");
  ret=read(fd, &reg , 1);


  if (ret != 1) {
    if (verbose > 0)
      perror(i2cdev);
  } else {
    if (verbose > 0) 
      printf("**** MATCH on I2C Address %03d\n",i2caddr);
  }
  close(fd);
  if (ret==1) return 0;
  else return 1;
}

///////////////////////////////////////////////////
//
//  SCAN I2C Bus
//
int detect(int i2caddr) {
  int i;

  if (check_i2c(i2caddr) == 0) return i2caddr;

  for (i=0;i<128;i++) 
    if( check_i2c(i) == 0) return i;
  return -1;
}




///////////////////////////////////////////////////
//
//  READ TTCRX REGISTER
//
int read_register(int regnum) {
  unsigned char buf[2];
  int reg=0;
  int ret;

#ifdef TESTMODE
  return 42;
#endif

  buf[0]=(unsigned char) regnum;

  ret=write(fd_pointer, buf, 1);
  if (ret != 1) {
    printf ("write_register: returned: %d\n",ret);
    perror("write_register - failed write");
    return -1;
  }

  ret=read(fd_register, &reg , 1);
  if (ret != 1) {
    perror("read_register - failed read");
    return -1;
  }

  return(reg);
}

///////////////////////////////////////////////////
//
//  WRITE TTCRX REGISTER
//
int write_register(int regnum, int value) {
  unsigned char buf[2];
  int ret;

#ifdef TESTMODE
  return 0;
#endif
  
  buf[0]=(unsigned char) regnum;

  ret=write(fd_pointer, buf, 1);
  if (ret != 1) {
    printf ("write_register: returned: %d\n",ret);
    perror("write_register - failed write");
    return -1;
  }

  buf[0]=(unsigned char) value;

  ret=write(fd_register, buf, 1);
  if (ret != 1) {
    printf("write_register: returned: %d\n",ret);
    perror("write_register - failed write");
    return -1;
  }
  return 0;
}

///////////////////////////////////////////////////
int opendev(char *filep) {
  int fp;
#ifdef TESTMODE
  return 42;
#endif
  fp = open (filep, O_RDWR);
  if(fp < 0) 
    perror(filep);
  return fp;
}
///////////////////////////////////////////////////
// 1= ttcrx is ready, 0: it is not ready
int ttcrxready() {
  unsigned char rd=0;
  int fp;
  fp=opendev((char *)ttcrxdev);
  if (fp < 0) return 0; // strange but ok
  if(read(fp,&rd,1) != 1) { perror("Read 1 Byte TTCRX Status"); rd=0; }
  close(fp);
  return((int) rd);

}

///////////////////////////////////////////////////
//
//  Read Event Counter
//
int read_event_counter(fd){
  int retval=0;
  retval  = read_register(28) << 16;
  retval += read_register(27) <<  8;
  retval += read_register(26);
  return retval;
}




///////////////////////////////////////////////////
//
//  MAIN
//
int main(int argc, char** argv) {
  int i;
  int i2caddr,i2caddrtemp;
  unsigned long int li_event_count;
  unsigned int i_bunchcross_count;
  char reg_array[20];
  char *argument;

  char ttcrx_lookup[20]={ 0,1,2,3,8,9,10,11,16,17,18,19,20,21,22,24,25,26,27,28 };
  int ttcrx_lookup_rev[29]={ 0,1,2,3,-4,-5,-6,-7,8,9,10,11,-12,-13,-14,-15,16,17,18,19,20,21,22,-23,24,25,26,27,28 };

  char *ttcrx_regname[20];
  ttcrx_regname[ 0]="Fine Delay 1                    ";
  ttcrx_regname[ 1]="Fine Delay 2                    ";
  ttcrx_regname[ 2]="Coarse Delay                    ";
  ttcrx_regname[ 3]="Control                         ";
  ttcrx_regname[ 4]="Single error count <7:0>        ";
  ttcrx_regname[ 5]="Single error count <15:8>       ";
  ttcrx_regname[ 6]="Double error count <7:0>        ";
  ttcrx_regname[ 7]="SEU error count <15:8>          ";
  ttcrx_regname[ 8]="ID <7:0>                        ";
  ttcrx_regname[ 9]="MasterModeA <1:0>, ID <13:8>    ";
  ttcrx_regname[10]="MasterModeB <1:0>, I2C_ID <5:0> ";
  ttcrx_regname[11]="Config 1                        "; 
  ttcrx_regname[12]="Config 2                        "; 
  ttcrx_regname[13]="Config 3                        "; 
  ttcrx_regname[14]="Status                          "; 
  ttcrx_regname[15]="Bunch counter <7:0>             "; 
  ttcrx_regname[16]="Bunch counter <15:8>            "; 
  ttcrx_regname[17]="Event counter <7:0>             "; 
  ttcrx_regname[18]="Event counter <15:8>            "; 
  ttcrx_regname[19]="Event counter <23:16>           "; 


  if (argc == 1) {
    const int defi2c=DEFAULTI2CADDR;
    printf("Usage: %s [xxx] <option>\n",argv[0]); 
    printf("\n");
    printf("Communication to TTCrx via i2c. Options:\n");
    printf("xxx       - TTCrx i2c address (default %d)\n",defi2c);
    printf("n         - dump TTCrx Registers numerical\n");
    printf("d         - dump TTCRx Registers with descriptions\n");
    printf("e         - printout event counter\n");
    printf("w val reg - Write val to register reg\n");
    printf("s         - Set Trigger output to Software (pretrigger from dcs2trap)\n");
    printf("t         - Set Trigger output to Hardware (L1Accept from TTCrx)\n");
    printf("o         - Set Trigger output to One-Shot-Trigger (Only one L1Accept from TTCrx)\n");
    printf("v         - Display version\n");

    printf("\n"); 
    printf("Example: %s %03d w 0x93 3\n",argv[0],defi2c); 
    return 0;
  }


  argument=argv[1];
  if (argument[0]=='-') argument[0]=argument[1]; // skip "-"

  if ( (argument[0] >= '0')  &&  (argument[0] <= '9') ) {
    if (argc == 2) {
      printf ("Missing arguments\n");
      return -1;
    }
    sscanf(&argument[0],"%d",&i2caddr);
    argument = argv[2];
    //    printf("Using i2c Addresses %03d and %03d\n",i2caddr,i2caddr+1);
  } else {
    i2caddr=DEFAULTI2CADDR;
  }


  if ( (argument[0] != 's')) {
    if (ttcrxready()) 
      printf("TTCRX is READY\n");
    else
      printf("***\n*** WARNING: TTCRX is not READY\n***\n");
  }



  switch (argument[0]) {
  case 'v':
    printf("ttcrx revision: %s\n",revision);
    return 0;
    break;
    //////////////////////////////////////////// 
  case 'e': break;
  case 'n': break;
  case 'd': break;
  case 'w': break;
  case 's': 
  case 'o':
    //////////////////////////////////////////// 
    // switch to software mode trigger (1 -> /dev/ttcrx)
    {
      int fp,ret;
      char val=1;
      fp=opendev((char *)ttcrxdev);
      if (fp < 0) return -1;
#ifndef TESTMODE
      ret = write(fp,&val,1);
      if (ret != 1) { 
	perror("Select Trigger Source");
	return -1;
      }
#endif
      close(fp);
      if (argument[0]=='s') 
	printf("Software Trigger selected\n");
      else
	printf("One-Shot-Trigger selected\n");
    }
    break;
    //////////////////////////////////////////// 
  case 't':
    //////////////////////////////////////////// 
    // switch to hardware mode trigger (0 -> /dev/ttcrx)
    {
      int fp,ret;
      char val=0;
      fp=opendev((char *)ttcrxdev);
      if (fp < 0) return -1;
#ifndef TESTMODE
      ret = write(fp,&val,1);
      if (ret != 1) { 
	perror("Select Trigger Source");
	return -1;
      }
#endif
      close(fp);
      printf("Hardware Trigger selected\n");
    }

    break;
  }


  i2caddrtemp=i2caddr;
  i2caddr=detect(i2caddrtemp);
  if (i2caddr == -1) {
    printf ("Detected no TTCRX on %d and not at any address\n",i2caddrtemp);
    return -1;
  }
  if (i2caddr != i2caddrtemp) {
    printf ("Detected no TTCRX on %d/%d, but on %d/%d\n",i2caddrtemp,i2caddrtemp+1,i2caddr,i2caddr+1);
  }

  sprintf(&pointerdev[9],"%03d",i2caddr);
  sprintf(&registerdev[9],"%03d",i2caddr+1);

  printf ("Using %s and %s\n",pointerdev,registerdev);

  fd_pointer = opendev((char *) pointerdev);
  if (fd_pointer < 0) return -1;
  fd_register = opendev((char *) registerdev);
  if (fd_register<0) return -1;

 

  switch (argument[0]) {
    //////////////////////////////////////////// 
  case 'e':
    //////////////////////////////////////////// 
    printf("Event Counter: %d\n",read_event_counter(0));
    break;
    //////////////////////////////////////////// 
  case 'n':
    //////////////////////////////////////////// 
    for (i=0;i<20;i++) 
      printf("%2d: 0x%02X\n",ttcrx_lookup[i],read_register(ttcrx_lookup[i]));
    break;
    //////////////////////////////////////////// 
  case 'd':
    //////////////////////////////////////////// 
    for (i=0;i<20;i++) {
      reg_array[i]=read_register(ttcrx_lookup[i]);
      //      printf("%2d %s: 0x%02X\n",ttcrx_lookup[i], ttcrx_regname[i],read_register(ttcrx_lookup[i])); reduce num of HW reads
      printf("%2d %s: 0x%02X\n",ttcrx_lookup[i], ttcrx_regname[i],reg_array[i]);
    }
    i_bunchcross_count = (((reg_array[16] & 0xff) << 8) | ((reg_array[15] & 0xff)));
    printf("\nBunch counter:    %05d",i_bunchcross_count);
    printf("   hex:   0x%04X\n",i_bunchcross_count);
    li_event_count = (((reg_array[19] & 0xff) << 16) | ((reg_array[18] & 0xff) << 8) | ((reg_array[17] & 0xff)));
    printf("\nEvent counter: %08ld",li_event_count);
    printf("   hex: 0x%06lX\n\n",li_event_count);
    
    break;
    //////////////////////////////////////////// 
  case 'w':
    //////////////////////////////////////////// 
    if (argc != 4) {
      printf("Write needs two arguments\n");
      return -1;
    } else {
      int reg=-1;
      int val=0;
      sscanf(argv[3],"%i",&reg);
      sscanf(argv[2],"%i",&val);
      if ( (reg < 0) || ( reg > 28 ) ) {
	printf("Register %d out of range\n",reg);
	return -1;
      }
      if (ttcrx_lookup_rev[reg] < 0 ) { 
	printf("Register %d invalid\n",reg);
	return -1;
      }
      printf("Writing value 0x%02x to register %d\n",val,reg);
      write_register(reg,val);
    }
    break;    

  case 's': break;
  case 'o': break;
  case 't': break;
  default:
    printf("Unknown option: %c\n",argument[0]);
    break;
  } // switch argument
    
    
  close(fd_register);
  close(fd_pointer);
  return(0);
}
