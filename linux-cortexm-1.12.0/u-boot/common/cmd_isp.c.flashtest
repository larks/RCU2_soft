/*
 * Command for accessing SPI flash.
 *
 * Copyright (C) 2008 Atmel Corporation
 * Licensed under the GPL-2 or later.
 */


#include <common.h>
#include <serial.h>
#include <ns16550.h>
#include <asm/io.h>
#include <spi_flash.h>
#include <netdev.h>
#include <asm/arch/ddr.h>
#include <asm/arch/comblk.h>
#include <exports.h>
#include <asm/arch/m2s.h>
#include <malloc.h>
#include <asm/io.h>


#ifndef CONFIG_SF_DEFAULT_SPEED
# define CONFIG_SF_DEFAULT_SPEED	1000000
#endif
#ifndef CONFIG_SF_DEFAULT_MODE
# define CONFIG_SF_DEFAULT_MODE		SPI_MODE_3
#endif

#define SPI_CLOCK_FF  50000000
//#define SPI_CLOCK_FF  5000000
const u32 apb_divisors_mask = 0x00000EFCU;
#define DELAY_MORE_THAN_10US        1000000

static NS16550_t serial_ports = (NS16550_t)CONFIG_SYS_NS16550_COM1;
extern void NS16550_init(NS16550_t com_port, int baud_divisor);
extern void clock_update(enum clock clck, unsigned long val);

#define FACC_STANDBY_SEL                                0u
#define MSS_25_50MHZ_EN                                 1u
#define MSS_1MHZ_EN                                     1u
#define FACC_STANDBY_SHIFT                              6u
#define MSS_25_50MHZ_EN_SHIFT                           9u
#define MSS_1MHZ_EN_SHIFT                               10u
#define FACC_STANDBY_SEL_MASK                           0x000001C0u
#define MSS_25_50MHZ_EN_MASK                            0x00000200u
#define MSS_1MHZ_EN_MASK                                0x00000400u
#define NVM_FREQRNG_MASK        0x00001FE0
#define NVM_FREQRNG_MAX         ((uint32_t)0xFF << 5)

void exec_ComBlk_IRQHandler(void);

static struct spi_flash *flash;
static unsigned long clock_base[CLOCK_END];
static volatile u32 g_initial_mssddr_facc1_cr = 0;
static volatile u32 g_initial_envm_cr = 0x00001FF1U;
static volatile u32 g_initial_mssddr_facc2_cr = 0x00;


void exec_ComBlk_IRQHandler(void){
  printf(" --- IRQ ---- \n");
}

static int do_spi_flash_probe(unsigned int  speed)
{
  unsigned int bus = 0;
  unsigned int cs = 0;
  //unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
  unsigned int mode = CONFIG_SF_DEFAULT_MODE;
  char *endp;
  //struct spi_flash *new;

  if (flash)
    spi_flash_free(flash);

  
  flash = spi_flash_probe(bus, cs, speed, mode);
  if (!flash) {
    printf("Failed to initialize SPI flash at %u:%u\n", bus, cs);
    return 1;
  }
  
  //flash = new;
  
  printf("%u KiB %s at %u:%u is now current device\n",
	 flash->size >> 10, flash->name, bus, cs);
  
  return 0;
  
  //usage:
  //puts("Usage: sf probe [bus:]cs [hz] [mode]\n");
  //return 1;
}

static int do_spi_flash_read(unsigned long offset)
{

  unsigned long len = 256make
;
  void *buf;
  char *endp;
  int ret;
  
  //  buf = map_physmem(addr, len, MAP_WRBACK);
  buf = malloc(len);
  if (!buf) {
    puts("Failed to map physical memory\n");
    return 1;
  }
  
  printf("sf read at Flash %p (spi=%p) and buf=%p\n", flash, flash->spi, buf);
  ret = spi_flash_read(flash, offset, len, buf);
  print_buffer(buf, buf, 4, len/4, 4);


  //unmap_physmem(buf, len);
  free(buf);

  if(ret) {
    printf("SPI flash read failed\n");
    return 1;
  }
  
  return 0;
}


static unsigned int exec_clock_mss_divisor(unsigned int r, unsigned int s)
{
  unsigned int v, ret;

  /*
   * Get a 3-bit field that defines the divisor
   */
  v = (r & (0x7<<s)) >> s;

  /*
   * Translate the bit representation of the divisor to 
   * a value ready to be used in calculation of a clock.
   */
  switch (v) {
  case 0: ret = 1; break;
  case 1: ret = 2; break;
  case 2: ret = 4; break;
  case 4: ret = 8; break;
  case 5: ret = 16; break;
  case 6: ret = 32; break;
  default: ret = 1; break;
  }

  return ret;
}

static int exec_calc_divisor(NS16550_t port){

  u32 baudrate = 115200;
  u32 MODE_X_DIV = 16;
  u32 NS16550_CLK = clock_base[CLOCK_PCLK1];
  
  return (NS16550_CLK + (baudrate * (MODE_X_DIV / 2))) /
    (MODE_X_DIV * baudrate);
  
}



static int exec_clock_mss_learn(u32 m2s_sys_clock)
{  

  u32 r1 = M2S_SYSREG->mssddr_facc1_cr;
  u32 r2 = M2S_SYSREG->mssddr_pll_status_low_cr;

  /*
   * System reference clock is defined as a build-time constant.
   * This clock comes from the FPGA PLL and we can't determine
   * its value at run time. All clocks derived from CLK_BASE
   * can be calculated at run time (and we do just that).
   */

  clock_base[CLOCK_SYSREF] = m2s_sys_clock; //CONFIG_SYS_M2S_SYSREF;
  /*
   * Respectively:
   * M3_CLK_DIVISOR
   * DDR
   * APB0_DIVISOR
   * APB1_DIVISOR
   * FIC32_0_DIVISOR
   */
  clock_base[CLOCK_SYSTICK] = clock_base[CLOCK_SYSREF] / exec_clock_mss_divisor(r1, 9);
  clock_base[CLOCK_DDR] = clock_base[CLOCK_SYSREF] / exec_clock_mss_divisor(r2, 16);
  clock_base[CLOCK_PCLK0] = clock_base[CLOCK_SYSREF] / exec_clock_mss_divisor(r1, 2);
  clock_base[CLOCK_PCLK1] = clock_base[CLOCK_SYSREF] / exec_clock_mss_divisor(r1, 5);
  clock_base[CLOCK_FPGA] = clock_base[CLOCK_SYSREF] / exec_clock_mss_divisor(r1, 13);

  return 1;
}


static int do_clock_switch(){

  u32 running_on_standby_clock;  
  volatile u32 timeout;
  u32 clk1;
  u32 clk2;
  u32 clock_divisor;

  printf("change the clock \n");


  M2S_SYSREG->envm_cr = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
  
  M2S_SYSREG->mssddr_facc2_cr = M2S_SYSREG->mssddr_facc2_cr & ((u32)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK);  
  M2S_SYSREG->mssddr_facc2_cr = M2S_SYSREG->mssddr_facc2_cr | ((u32)(MSS_25_50MHZ_EN << MSS_25_50MHZ_EN_SHIFT) & MSS_25_50MHZ_EN_MASK);  
  M2S_SYSREG->mssddr_facc2_cr = M2S_SYSREG->mssddr_facc2_cr | ((u32)(MSS_1MHZ_EN << MSS_1MHZ_EN_SHIFT) & MSS_1MHZ_EN_MASK);        
  M2S_SYSREG->mssddr_facc2_cr |= 0x2;



  M2S_SYSREG->mssddr_facc1_cr |= (1<<12);

  timeout = DELAY_MORE_THAN_10US;
  do
    {
      running_on_standby_clock = M2S_SYSREG->mssddr_facc1_cr & 0x00001000;
      --timeout;
    }
  while ((running_on_standby_clock == 0U) && (timeout != 0U));

  //M2S_SYSREG->mssddr_facc1_cr &= ~(1<<27);
  udelay(10000);
  M2S_SYSREG->mssddr_facc1_cr &= ~apb_divisors_mask;
  udelay(10000);

  

  //M2S_SYSREG->mssddr_facc1_cr = 0xa804148;

  exec_clock_mss_learn(50000000);
  //exec_clock_mss_learn(160000000);
  clock_divisor = exec_calc_divisor(serial_ports); 
  NS16550_init(serial_ports, clock_divisor);

  clock_update(CLOCK_SYSREF, clock_base[CLOCK_SYSREF]);
  clock_update(CLOCK_SYSTICK, clock_base[CLOCK_SYSTICK]);
  clock_update(CLOCK_DDR, clock_base[CLOCK_DDR]);
  clock_update(CLOCK_PCLK0, clock_base[CLOCK_PCLK0]);
  clock_update(CLOCK_PCLK1, clock_base[CLOCK_PCLK1]);
  clock_update(CLOCK_FPGA, clock_base[CLOCK_FPGA]);

  clk1 = clock_base[CLOCK_PCLK0];
  clk2 = clock_get(CLOCK_PCLK0);//clock_base[CLOCK_PCLK1];

  udelay(10000);
  printf(" facc1=0x%x, facc2=0x%x, clk0=%d, clk1=%d (div=%d). SPI clock=%d\n", 
         M2S_SYSREG->mssddr_facc1_cr, 
         M2S_SYSREG->mssddr_facc2_cr, 
         clk1, clk2, clock_divisor, SPI_CLOCK_FF);
  udelay(10000);

  return 1;

}

static int do_isp_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
  
  const char *cmd;
  if (argc < 2)
    goto usage;

  cmd = argv[1];

  ///////
  g_initial_envm_cr = M2S_SYSREG->envm_cr;
  g_initial_mssddr_facc1_cr = M2S_SYSREG->mssddr_facc1_cr;
  g_initial_mssddr_facc2_cr = M2S_SYSREG->mssddr_facc2_cr;
  
  printf("SYSREG_ENVM_CR = 0x%x\n", g_initial_envm_cr);
  printf("SYSREG_MSSDDR_FACC1_CR = 0x%x\n", g_initial_mssddr_facc1_cr);
  printf("SYSREG_MSSDDR_FACC2_CR = 0x%x\n", g_initial_mssddr_facc2_cr);  
  ///////

  if (strcmp(cmd, "c") == 0){
    do_spi_flash_probe(CONFIG_SF_DEFAULT_SPEED);
  }else if(strcmp(cmd, "s") == 0){
    do_clock_switch();
    do_spi_flash_probe(SPI_CLOCK_FF);
  }


  /* The remaining commands require a selected device */
  if (!flash) {
    puts("No SPI flash selected. Please run `sf probe'\n");
    return 1;
  }
  
  do_spi_flash_read(0x200000);
  do_spi_flash_read(0x200000+64);
  do_spi_flash_read(0x200000+64*2);
  do_spi_flash_read(0x200000+64*3);
  do_spi_flash_read(0x200000+64*4);
  do_spi_flash_read(0x200000+64*5);
  do_spi_flash_read(0x200000+64*6);
  

  //spi_flash_free(flash);

  return 1;

usage:
	cmd_usage(cmdtp);
	return 1;
}

U_BOOT_CMD(
	isp,	2,	1,	do_isp_cmd,
	"ISP Programming",
	"isp [c/a/p/v/apv]- c:check comblk, a:authentication\n"
);
